## Traveling Salesman Problem2 (TSP2)

**Difficulty:** None

https://algospot.com/judge/problem/read/TSP2

NP-Complete 문제의 가장 유명한 예 중 하나인 여행하는 외판원 문제 (Traveling Salesman Problem) 은, 여러 개의 도시와 그 도시 간의 거리가 주어졌을 때, 각 도시를 정확히 한 번씩 방문하는 가장 짧은 경로를 찾는 문제이다. <br/>
이 문제를 다항 시간에 해결할 수 있는 방법은 현재까지는 존재하지 않지만, 도시의 숫자가 작은 경우에는 비교적 사용 가능한 시간 안에 문제를 해결할 수 있다. <br/>
AOJ 에서 이 문제는 같은 내용을 가진 문제 여러 개로 구성된다. 문제 번호에 비례해 도시의 개수가 올라가므로, 뒤로 갈수록 더욱 효율적인 방법을 써야 해결할 수 있다. <br/>
도시의 수 N <= 15 이라고 할 때, 여행하는 외판원 문제를 해결하는 프로그램을 작성하라.<br/><br/>

입력 <br/>
입력의 첫 줄에는 테스트 케이스의 수 C (<= 50) 이 주어진다. <br/>
각 테스트 케이스의 첫 줄에는 도시의 수 N (3 <= N <= 15) 이 주어진다. <br/>
그 후 N 줄에, 각 N 개씩의 실수로 도시간의 거리가 주어진다. 도시들은 1 부터 N 까지의 숫자로 표현되며, i 번째 줄의 j 번째 실수는 i번째 도시와 j번째 도시 사이의 거리이다. <br/>
각 거리는 0 이상 1415 이하이고, 소수점 밑 열 자리까지 주어진다. <br/>
주어진 행렬은 대칭이며, 입력되는 거리들은 삼각 부등식 (triangle inequality) 을 만족한다고 가정해도 좋다. <br/><br/>

출력 <br/>
테스트 케이스마다 한 줄에 최소 경로의 길이를 소수점 밑 열 자리까지 출력한다. <br/>
1e-7 이하의 절대/상대 오차가 있어도 맞는 답으로 인정한다.

```
Input:
2
3
0.0000000000  611.6157225201  648.7500617289
611.6157225201  0.0000000000  743.8557967501
648.7500617289  743.8557967501  0.0000000000
4
0.0000000000  326.0008994586  503.1066076077  290.0250922998
326.0008994586  0.0000000000  225.1785728436  395.4019367384
503.1066076077  225.1785728436  0.0000000000  620.3945520632
290.0250922998  395.4019367384  620.3945520632  0.0000000000

Output: 
1260.3657842490
841.2045646020
```

**Note:**

**Show tag:** \#exhaustive\_search \#dynamic\_programming \#bit\_mask

**Related problem:** <br/>
exhaustive\_search.traveling\_salesman\_problem1

------------------------------------

**Main** <br/>
시간복잡도 : O(2^n \* n) 공간복잡도 : O(2^n \* n ) <br/>
exhaustive\_search.traveling\_salesman\_problem1문제에 메모리제이션을 적용하여서 더 큰 n에 대해서도 동작하도록 개선하였다. <br/>
이 문제에서는 방문한 지점에 대해서 알고있어야 하므로 getMinPathLength(int visit, int startPoint)함수를 만들어서 메모리제이션을 하였다.(visit에 저장된 방문기록을 가지고 startPoint에서 시작할 때 만들 수 있는 minPathLength) <br/>
visit은 비트마스크 기법을 이용하여 방문한 지점들을 저장하였다. <br/>
n이 3이면 111 하면 모두 방문한것이고 110이면 2번,3번 지점을 방문한것이다. <br/>
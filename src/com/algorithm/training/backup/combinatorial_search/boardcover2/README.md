## BOARDCOVER2

**Difficulty:** Easy

https://algospot.com/judge/problem/read/BOARDCOVER2

H×W 크기의 게임판과 한 가지 모양의 블록이 여러 개 있습니다. <br/>
게임판에 가능한 많은 블록을 올려놓고 싶은데, 게임판은 검은 칸과 흰 칸으로 구성된 격자 모양을 하고 있으며 이 중에서 흰 칸에만 블록을 올려놓을 수 있습니다. <br/>
이때 블록들은 자유롭게 회전해서 놓을 수 있지만, 서로 겹치거나, 격자에 어긋나게 덮거나, 검은 칸을 덮거나, 게임판 밖으로 나가서는 안 됩니다. <br/>

(사진생략) <br/>

위 그림은 예제 게임판과 L 자 모양의 블록으로 이 게임판을 덮는 방법을 보여줍니다. <br/>
게임판에는 15개의 흰 칸이 있고, 한 블록은 네 칸을 차지하기 때문에 그림과 같이 최대 세 개의 블록을 올려놓을 수 있지요. <br/>
게임판과 블록의 모양이 주어질 때 최대 몇 개의 블록을 올려놓을 수 있는지 판단하는 프로그램을 작성하세요. <br/>

입력 <br/>
입력의 첫 줄에는 테스트 케이스의 수 T (T≤100)가 주어집니다. 각 테스트 케이스의 첫 줄에는 게임판의 크기 H, W (1≤H, W≤10), 그리고 블록의 모양을 나타내는 격자의 크기 R, C (1≤R, C≤10)가 주어집니다. 다음 H줄에는 각각 W 글자의 문자열로 게임판의 정보가 주어집니다. 문자열의 각 글자는 게임판의 한 칸을 나타내며, #은 검은 칸, 마침표는 흰 칸을 의미합니다. 다음 R줄에는 각 C 글자의 문자열로 블록의 모양이 주어집니다. 이 문자열에서 #은 블록의 일부, 마침표는 빈 칸을 나타냅니다. <br/>
각 게임판에는 최대 50개의 흰 칸이 있으며, 각 블록은 3개 이상 10개 이하의 칸들로 구성됩니다. 변을 맞대고 있는 두 변이 서로 연결되어 있다고 할 때, 블록을 구성하는 모든 칸들은 서로 직접적 혹은 간접적으로 연결되어 있습니다.

출력 <br/>
각 테스트 케이스마다 게임판에 놓을 수 있는 최대의 블록 수를 출력합니다.

```
Input:
1
2
4 7 2 3
##.##..
#......
#....##
#..####
###
#..
5 10 3 3
..........
..........
..........
..........
..........
.#.
###
..#

Output: 
3
8
```

**Note:**

**Show tag:** \#combinatorial\_search \#dynamic\_programming

**Realted Problem:** exhaustive_search.boardcover

------------------------------------

**Best Main : Unsolved Solution(Time Limit Excceed)** <br/>
시간복잡도 : ? 공간복잡도 : O(n*m) (n=보드가로크기 m=보드세로크기) <br/>
_시간복잡도를 정확하게 계산하기가 어렵다_ <br/>
boardcover 문제의 확장판으로 가장 많은 칸을 덮는 방법을 세는 최적화 문제이다. <br/>
boardcover 문제와 마찬가지로 아직 비어있는 칸 중에서 가장 왼쪽 상단에 있는 칸부터 채워나간다는 규칙으로 boardcover에서는 중복해서 세는것을 방지하였지만, 이 문제에서는 같은 상태를 여러번 방문하는 것을 줄여 시간복잡도를 줄인다. <br/>

주어진 블록의 형태를 가지고 왼쪽 상단을 기준으로 상대좌표 리스트를 만들어서 저장하는데, <br/>
90도 회전을 3번 시켜 총 4가지의 상대좌표를 얻어서 저장해둔다. <br/>
만약 회전했을 떄 블록의 형태가 동일하다면 리스트에서 제외시켜서 중복해서 체크하는 것을 방지한다. <br/>

countMaxBlock(int i, int j, int currentBlockCount, int remainedBlanckCount)는 board의 (i,j)에서 시작하여 현재까지의 놓은 블록의 개수가 currentBlcokCount이며 보드의 남은 빈 공간이 remainedBlankCount일 때 놓을 수 있는 최대 블록의 개수로 정의한다. <br/>
이 메소드에서는 보드에서 비어있는 칸 중에서 가장 왼쪽 상단을 구해서 해당 빈칸에 놓을 수 있는 모양의 블록들을 놓는다. <br/>
또한 블록을 놓지 않고 빈채로 남겨두는 경우도 고려하기 위해서 해당 경우도 처리해준다. (이 경우에는 해당칸을 절대 덮지 않기 위해서 보드에서 해당칸을 채워진 상태로 바꿔주고 countMaxBlock(i, j, curretnBlockCount, remainedBlanckCount-1)로 호출해준다. <br/>

이렇게 완전 탐색을 하면 수행시간이 오래걸리는데 가지치기를 이용하여 수행시간을 줄인다. <br/>
보드에 남아있는 빈칸의 개수를 블록의 크기로 나눠주면 해당 보드에 놓을 수 있는 블록의 최대개수의 상한이 된다. <br/>
만약 지금까지 놓은 블록의 개수와 블록의 최대 개수의 상한의 합이 지금까지 구해둔 블록의 최대 개수보다 작다면 더이상 탐색을 할 필요가 없으므로 탐색을 종료한다. <br/>

_TLE가 발생하는데 왜 발생하는지 원인을 못찾겠다. 그래서 미해결문제로 남겨둔다. 나중에 C++공부하여 C++로 동일로직으로 풀어보고싶다._
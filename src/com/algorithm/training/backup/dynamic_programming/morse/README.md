## MORSE

**Difficulty:** Medium

https://algospot.com/judge/problem/read/MORSE

모스 부호(Morse code)는 전화가 없던 시절 무선 전신에 주로 사용하던 코드로, 짧은 신호(단점, o)와 긴 신호(장점, -)를 섞어 글자를 표현하는 표현방식입니다. <br/>
예를 들어 알파벳 J는 모스 부호 o---로 표현되고, M은 --로 표현됩니다. <br/>

n개의 장점과 m개의 단점으로 구성된 모든 신호들을 담고 있는 사전이 있다고 합시다. <br/>
예를 들어 n = m = 2라면 다음과 같은 신호들이 포함되어 있는 것이죠. <br/>
--oo <br/>
-o-o <br/>
-oo- <br/>
o--o <br/>
o-o- <br/>
oo-- <br/>
이 신호들은 사전순서대로 정렬되어 있습니다.  <br/>
-의 아스키 코드는 45이고, o의 아스키 코드는 111이기 때문에 -가 먼저 오게 되죠. <br/>
n과 m이 주어질 때 이 사전의 k번째 신호를 출력하는 프로그램을 작성해 봅시다. <br/>
예를 들어 위 사전에서 네 번째 신호는 o--o입니다. <br/>

입력 <br/>
입력의 첫 줄에는 테스트 케이스의 수 C(≤50)가 주어집니다. 각 테스트 케이스는 세 개의 정수 n, m(1≤n, m≤100), k(1≤k≤1,000,000,000)로 주어집니다. 사전에는 항상 k개 이상의 신호가 있다고 가정해도 좋습니다.

출력 <br/>
각 테스트 케이스마다 한 줄에 해당 신호를 출력합니다.

```
Input:
3
2 2 4
4 8 13
6 4 1

Output: 
o--o
--o-ooo-oooo
------oooo
```

**Note:**

**Show tag:** \#dynamic\_programming

------------------------------------

**Main** <br/>
시간복잡도 : O(n+m) 공간복잡도 : O(1) <br/>
k번째 신호를 찾을때 맨 앞에서부터 -인지 o인지를 채워나간다. <br/>
맨 앞 신호가 -일때 만들어지는 신호의 개수는 C(n+m-1, n-1)이다. <br/>
만약 이 개수가 k이하면 맨 앞의 신호는 - 인것이고 k초과이면 o이다. <br/>
이런식으로 맨앞의 신호를 찾는 함수를 재귀호출하여 최종적으로 k번째 신호를 구한다. <br/>

이문제에서 관심있게 봐야할 부분은 조합이다. <br/>
조합은 파스칼의 삼각형을 이용해서 구할 수 있으므로 2차원 배열에 모든 조합의 수를 미리 저장해둔다. <br/>
n+m의 최대값은 200이므로 200x200배열에 조합의 수를 채워넣는데, 계산하다보면 int범위를 벗어난다. <br/>
그러나 k의 최대값은 1000000000이므로 1000000000이 넘는 경우는 고려할 필요가 없으므로 임의의값으로 처리해둔다.
## K-th Longest Increasing Sequence(KLIS)

**Difficulty:** Hard

https://algospot.com/judge/problem/read/KLIS

어떤 정수 수열에서 0개 이상의 숫자를 지우면 이 수열의 부분 수열 (subsequence) 를 얻을 수 있다. <br/>
예를 들어 10 7 4 9 의 부분 수열에는 7 4 9, 10 4, 10 9 등이 있다. <br/>
단, 10 4 7 은 원래 수열의 순서와 다르므로 10 7 4 9 의 부분 수열이 아니다.

어떤 부분 수열이 _단조 증가_할 때 이 부분 수열을 증가 부분 수열 (increasing subsequence) 라고 하며, 이 중 가장 긴 것을 최대 증가 부분 수열 (LIS, longest increasing subsequence) 라고 한다. <br/>
예를 들어, 5 20 21 22 8 9 10 의 최대 증가 부분 수열은 5 8 9 10 이다.

어떤 수열에는 LIS 가 두 개 이상 있을 수 있다. 예를 들어, 4 5 6 1 2 3 의 LIS 는 두 개가 있다. <br/>

모든 숫자가 서로 다른 (중복 숫자가 없는) 수열이 주어질 때, 이 수열의 LIS 중 사전 순서대로 맨 앞에서 k번째 있는 LIS 를 출력하는 프로그램을 작성하시오. <br/>

입력 <br/>
입력의 첫 줄에는 테스트 케이스의 수 C (<= 50) 가 주어진다. 각 테스트 케이스의 첫 줄에는 수열에 포함된 원소의 수 N (<= 500) 과 K 가 주어진다. K 는 32비트 부호 있는 정수에 저장할 수 있다. 그 다음 줄에 N개의 정수로 수열이 주어진다. 각 정수는 1 이상 100,000 이하이며, 같은 수는 두 번 등장하지 않는다.
주어진 수열의 LIS 는 최소 K 개 있다고 가정해도 좋다.

출력 <br/>
각 테스트케이스마다 두 줄을 출력한다. 첫 줄에는 LIS 의 길이 L 을 출력하고, 그 다음 줄에 L 개의 정수로 K번째 LIS 를 출력한다.

```
Input:
3
9 2
1 9 7 4 2 6 3 11 10
8 4
2 1 4 3 6 5 8 7
8 2
5 6 7 8 1 2 3 4

Output: 
4
1 2 3 11
4
1 3 6 8
4
5 6 7 8
```

**Note:**

**Show tag:** \#dynamic\_programming

------------------------------------

**Main : Unsolved Problem** <br/>
_시간복잡도의 산출이 어려움_ 공간복잡도 : O(n) <br/>
알고리즘 문제해결전략 책을 참고하여 내 방식대로 풀었지만 런타임에러가 나서 미해결 상태이다. <br/>
문제의 솔루션은 크게 3단계인데 아래와 같다. <br/>
1. input의 LIS 최대 길이를 구한다.
	* dynamicprograaming.lis 문제에서 구현한 코드를 이용하여 getMaxLength 메소드를 구현하였다.
	* 이 떄 3번을 위해서 map에다가 maxLength를 key로 가지며 value에는 정수의 범위를 수용가능한 100001 사이즈의 배열을 만들어 두고, 해당 배열의 정수크기의 인덱스에다가 해당 정수의 numbers에서의 index를 넣어서 표현해둔다. (ex. i=2, numbers[i]=3, getMaxLength(i)=5 -> map.get(5)[3] = 2)
2. input의 LIS 최대 길이를 만들 수 있는 LIS의 개수를 구한다.
	* i번쨰의 수와 j번째의 수가 있을 떄(i<j) getMaxLength(i) == getMaxLength(j)+1 이면 i다음에 j가 왔을 때 LIS의 최대길이를 구할 수 있다는 것이기므로 해당의 조건이 성립될때마다 카운트해줘서 개수를 구한다.
3. 1번과 2번을 이용해서 k번째 최대 길이의 LIS 수열을 얻는다. 
	1. 수열의 맨 앞에서부터 하나씩 완성해나가는 방식을 택하였다.
	2. 1번에서 만들어둔 map을 이용하여 최대길이를 얻을 수 있는 정수들의 리스트를 얻는다. (배열을 순회해서 배열의 값이 초기값인 -1이 아닌경우를 얻으면 자연스럽게 사전순으로 정렬된 정수리스트를 얻을 수 있다.)
	3. 정수 리스트에서 앞에서부터 2번을 이용하여 해당 지점에서 최대 길이의 LIS 개수를 얻는다.
	4. 개수가 k보다 작으면 해당 정수는 패스해도 되는것이므로 패스하고 다음 정수를 보며, 개수가 k이상이면 해당 정수로 만드는 LIS 수열들에 k번째 수열이 포함되어 있는것이므로 해당 정수를 수열에 추가한다. 그 후 최대길이-1와 k-개수로 해당 메소드를 재귀호출하면서 수열을 완성시켜나간다.
## ALLERGY

**Difficulty:** Medium

https://algospot.com/judge/problem/read/ALLERGY

집들이에 n 명의 친구를 초대하려고 합니다. 할 줄 아는 m 가지의 음식 중 무엇을 대접해야 할까를 고민하는데, 친구들은 각각 알러지 때문에 못 먹는 음식들이 있어서 아무 음식이나 해서는 안 됩니다. <br/>
만들 줄 아는 음식의 목록과, 해당 음식을 못 먹는 친구들의 목록이 다음과 같은 형태로 주어진다고 합시다. <br/>

친구		갈비찜	피자		잡채		떡볶이	탕수육	닭강정 <br/>
채린		x		o		o		o		x		x <br/>
봄		x		x		x		x		o		o <br/>
다라		o		x		o		x		o		x <br/>
민지		o		o		x		x		x		o <br/>

각 친구가 먹을 수 있는 음식이 최소한 하나씩은 있도록 하려면 최소 몇 가지의 음식을 해야 할까요? <br/>
위 경우라면 다 같이 먹을 수 있는 음식이 없기 때문에 결국 두 가지 이상 음식을 해야 합니다. <br/>
피자와 탕수육, 혹은 잡채와 닭강정처럼 두 개 이상의 음식을 선택해야만 모두가 음식을 먹을 수 있지요. <br/>
친구들의 정보가 주어질 때 최소한 만들어야 하는 요리의 가지수를 계산하는 프로그램을 작성하세요. <br/>

입력 <br/>
입력의 첫 줄에는 테스트 케이스의 수 T (T <= 50 ) 가 주어집니다. 각 테스트 케이스의 첫 줄에는 친구의 수 n (1 <= n <= 50) 과 할 줄 아는 음식의 수 m (1 <= m <= 50) 이 주어집니다. 다음 줄에는 n 개의 문자열로 각 친구의 이름이 주어집니다. 친구의 이름은 10 자 이하의 알파벳 소문자로만 구성된 문자열입니다. 그 후 m 줄에 하나씩 각 음식에 대한 정보가 주어집니다. 각 음식에 대한 정보는 해당 음식을 먹을 수 있는 친구의 수와 각 친구의 이름으로 주어집니다.
모든 친구는 하나 이상의 음식을 먹을 수 있다고 가정해도 좋습니다.

출력 <br/>
각 테스트 케이스마다 한 줄에 만들어야 할 최소의 음식 수를 출력합니다.

```
Input:
2
4 6
cl bom dara minzy
2 dara minzy
2 cl minzy
2 cl dara
1 cl
2 bom dara
2 bom minzy
10 7
a b c d e f g h i j
6 a c d h i j
3 a d i
7 a c f g h i j
3 b d g
5 b c f h i
4 b e g j
5 b c g h i 

Output: 
2
3
```

**Note:**

**Show tag:** \#combinatorial\_search \#dynamic\_programming

------------------------------------

**Main : Unsolved Solution (wrong answer)** <br/>
시간복잡도 : O(?) 공간복잡도 : O(1) (n=친구의수, m=음식개수) <br/>
_원래는 캐시를 적용하려고 했던 풀이방법인데 food개수의 maximum이 50이므로 2^50의 배열이 필요한데 이를 선언할 수 없으므로 잘못된 아이디어였다. (애초에 wrong answer로 시간초과까지 가지 못하였지만..)_ <br/>
_캐시를 적용하지 못해 시간복잡도를 계산하기가 어렵다. 만약 

setMinFoodCount(int friendNumber, int makeFood, int currentFoodCount)를 fiendNumber번째 친구가 먹을 수 있는 음식을 만들 차례이며, makeFood에는 지금까지 만든 food의 정보가 비트마스크로 주어지고, 현재까지 currentFoodCount개수의 음식을 만들었을 때의 최소로 만들어야하는 음식의 개수를 반환하는 메소드로 정의한다. <br/>

지금까지 만든 음식 중에 현재 친구가 먹을 수 있는 음식이 있다면 음식을 만들지 않고 다음 친구로 넘어가며, <br/>
먹을 수 있는 음식이 없다면 현재 친구가 먹을 수 있는 음식들을 모두 만들어본다. <br/>
이런식으로 모든 경우를 확인하여 최소 음식가짓수를 구하려고 하였다. <br/>
그러나 wrong answer가 발생하였으며 원인은 모르겠다.

가지치기를 이용하여 앞으로 지금까지의 최소 음식 가짓수보다 현재 음식가짓수가 같거나 커버리면 더이상 탐색을 중단한다.

**Main2** <br/>
시간복잡도 : O(n\*(m\*m+n)) 공간복잡도 : O(n\*m) (n=친구의수, m=음식개수) <br/>
메소드가 호출될 때마다 한명의 친구가 음식을 먹을 수 있게 되므로 호출은 n번 되며 메소드 내부에서 반복문이 n번, m\*m번 있으므로 시간복잡도는 n\*(m\*m+n)이다. <br/>
_이 솔루션에서는 메소드가 호출될 때마다 음식을 만들지 않는다. 타겟 친구가 이미 먹을 수 있는 음식이 있다면 음식을 만들지 않고 다음재귀호출로 넘어간다. 이는 Main3에서 메소드가 호출될 떄마다 음식의 가짓수가 하나씩 늘어나도록 개선하였다._

setMinFoodCount(int currentFoodCount)를 현재까지 만든 음식의 개수가 currentFoodCount일 때 모든 친구들이 다 음식을 먹게 하기 위해 만들어야 하는 음식의 최소값을 반환하는 메소드로 정의한다. <br/>

3개의 저장공간을 사용하는데 각각의 저장공간의 용도는 다음과 같다. <br/>
* List<List<Integer>> canEatFoodList : 각각의 친구마다 먹을 수 있는 음식 list를 저장하는 lists
* boolean[] makeFood : 만든 음식은 true / 만들지 않은 음식은 false
* boolean[] makeFoodForFriend : index의 친구를 위한 음식을 만들었다면 true/ 아니라면 False

canEatFoodList 리스트를 순회하면서 타겟으로 지정되지 않은 친구들 중 가장 먹을 수 있는 음식의 가짓수가 적은 친구를 선택한다. <br/>
_(원래는 아직 먹을 음식이 없는 친구들 중 먹을 수 있는 음식 가짓수가 가장 적은 친구를 선택하는 것이 좋은데, <br/>
이 솔루션에서는 음식을 만들고나서 해당 음식을 먹을 수 있는 친구들을 표시해두는 부분이 없기 때문에 <br/>
makeFoodForFriend의 정의가 애매하며 makeFoodForFriend의 값이 false라고 할지라도 현재 먹을 수 있는 음식이 없다는 것을 의미하지 않는다. 이부분을 리펙토링하여 짠 코드가 Main3이다.)_ <br/>
그 후 해당 친구가 먹을 수 있는 음식 리스트를 canEatFoodList에서 받아 온 후 <br/>
각각의 음식들이 아직 만들어지지 않았다면 음식을 만들고 재귀호출 하여 최소 음식 가짓수를 얻는다.

가지치기를 위해 curretnFoodCount가 지금까지 구한 최소 음식 가짓수보다 같거나 크다면 더이상 탐색을 중단한다.

**Main3** <br/>
시간복잡도 : O(m\*(n\*m)) 공간복잡도 : O(n\*m) (n=친구의수, m=음식개수) <br/>
메소드가 호출될 때마다 하나의 음식이 요리되므로 최대 m번 호출 될 수 있으며, 메소드 내부에서 반복문이 n번, n\*m번 있으므로 시간복잡도는 m \*(n\*m)이다. <br/>

Main2 솔루션과 같은 로직이며 Main2를 리펙토링하여 좀 더 개선한 코드이다. <br/>

Main2와의 차이점은 아래와 같다. <br/>
1. makeFoodForFriend 배열에는 index의 친구가 먹을 수 있는 음식의 개수를 저장해둔다. <br/>
2. 메소드의 시작에서 canFoodList 리스트를 순회하면서 Main2에서는 타겟으로 지정되지 않았던 친구들 중 가장 먹을 수 있는 음식의 가짓수가 적은 친구를 선택했다면, Main3에서는 현재까지 만든 음식중에 먹을 수 있는 음식이 없는 친구들 중 가장 먹을 수 있는 음식 가짓수가 적은 친구를 선택하도록 하였다.
	* Main2에서는 선택된 친구가 이미 먹을 수 있는 음식이 있는 경우가 있었으므로 메소드 호출당 한명의 친구에대한 선택을 한 반면에 Main3에서는 먹을 수 있는 음식이없는 친구들 중에 선택하므로 메소드 호출당 하나의 음식에 대한 선택을 하게 된다.)
	* 먹을 수 있는 음식이 없는 친구들 중 가장 먹을 수 있는 음식 가짓수가 적은 친구를 선택하는 것은 좀더 좋은 답을 초반에 찾아내서 가지치기가 더 잘 될 수 있도록 한다. (두 가지 음식만 먹을 수 있는 친구에게 어느 음식을 해 줄지 결정하기가 열 가지 음식을 먹을 수 있는 친구에게 어떤 음ㅅ기을 해 줄지 결정하기보다 수비다. 또한 열 가지 음식을 먹을 수 있는 친구는 따로 챙겨주지 ㅇ낳아도 먹을 걸 찾게 될 가능성도 크다.)
3. 해당 친구가 먹을 수 있는 음식 리스트를 canEatFoodList에서 받아 온 후 각각의 음식을 만들고 재귀호출 하여 최소 음식 가짓수를 얻는다. 음식을 만들고 난 후에에는 maekFoodForFriend 배열에 해당 음식을 먹을 수 있는 친구들의 정보를 업데이트 해준다.
	* Main2의 경우에는 해당 친구가 먹을 수 있는 음식이 이미 있어서 음식을 만들 필요가 없는 경우도 있지만 Main3에서는 애초에 먹을 음식이 없는 친구를 선택하기 때문에 무조건 만든다. <br/>



**더 최적화하기**
Main3의 솔루션에서 음식을 선택할 때, 가장 많은 사람이 먹을 수 있는 음식부터 시도해보기 <br/>
한명만 먹을 수 있는 음식은 가능한 마지막에 방법이 없을 때 시도하는것이 좋다. <br/>
답을 초반에 찾아내서 가지치기를 더 잘 할 수 있도록 해준다.
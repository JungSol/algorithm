** 알고리즘 문제해결전략 **

6장. 무식하게 풀기
* 최적화 문제 (Optimization problem)
	* 문제의 답이 하나가 아니라 여러 개이고, 그 중에서 어떤 기준에 따라 가장 좋은 답을 찾아내는 문제
	* n개의원소 중에서 r개를 순서없이 골라내는 방법의 수를 계산하는 것은 답이 하나밖에 없고, 더 좋은 답이나 덜 좋은 답이 없으므로 Optimization problem이 아님
	* n개의 사과 중에서 r개를 골라서 무게의 합을 최대화 하는 문제 or 가장 무거운 사과와 가장 가벼운 사과의 무게 차이를 최소화하는 문는 Optimization problem
	* 최적화문제를 풀기위한 가장 기초적인 것이 완전탐색 : 가능한 답을 모두 생성해 보고 그중 가장 좋은 것을 찾아냄

* 자주등장하는 완전탐색유형
	* 모든 순열 만들기
		* 서로 다른 N개의 원소를 일렬로 줄 세운 것
		* 시간복잡도 : O(N!)
		* N이 10을 넘어간다면 완전탐색에 적합하지 않음
		* c++에서는 표준 라이브러리인 STL에 포함된 next_permutation() 함수에서 모든 순열을 순서대로 생성하는 작업을 해줌
	* 모든 조합 만들기
		* 서로 다른 N개의 원소에서 R개를 순서 없이 골라낸 것
		* 시간복잡도 : 이항계수 (N R)
	* 2^N가지 경우의 수 만들기
		* N개의 질문에 대한 답이 예/아니오 중의 하나라고 할 때 존재할 수 있는 모든 조합의 수
		* 시간복잡도 : O(2^N)

예제 <br/>
1. 보글게임(BOGGLE) : solve(2017-10-03)
2. 소풍(PICNIC) : solve(2017-10-04) 
3. 게임판덮기(BOARDCOVER) 
4. 여행하는 외판원 문제(Traveling Sales-man Problem, TSP) : solve(2017-10-04)
5. 시계 맞추기(CLOCKSYNC)

7장. 분할정복
* 분할 정복 알고리즘의 3가지 구성 요소
	1. divide :문제를 더 작은 문제로 분할
	2. merge : 각 묹에 대해 구한 답을 원래 문제에 대한 답으로 병합
	3. base case : 더이상 답을 분할하지 않고 곧장 풀 수 있는 매우 작은 문제

* 분할 정복 문제의 특성
	* 문제를 둘 이상의 부분문제로 나누는 자연스러운 방법이 있어야 하며,
	* 부분 문제의 답을 조합해 원래 문제의 답을 계산하는 효율적인 방법이 있어야 함
	
예제 <br/>
1. 1부터 n까지의 합 구하기(SumOfNumbers) : solve(2017-10-05)
2. 행렬의 거듭제곱
3. 병합 정렬과 퀵 정렬
4. 카라츠바의 빠른 곱셈 알고리즘
5. 쿼드 트리 뒤집기(QUADTREE) : solve(2017-10-05)
6. 울타리잘라내기 (FENCE) : solve(2017-10-06)
7. 팬미팅 (FANMEETING)

8장. 동적 계획법

* 동적계획법(dynamic programming)
	* 처음 주어진 문제를 더 작은 문제들로 나눈 뒤 각 조각의 답을 계산하고, 이 답들로부터 원래 문제에 대한 답을 계산

* 동적계획법과 분할정복의 차이
	* 문제를 나누는 방식
	* 동적 계획법에서 어떤 부분 문제는 두 개 이상의 문제를 푸는데 사용될 수 있기 때문에, 이 문제의 답을 여러번 계산하는 대신 한 번만 계산하고 계산결과를 재활용함으로써 속도의 향상을 꾀할 수 있음

* 메모리제이션
	* 캐시(cache) : 이미 계싼한 값을 저장해 두는 메모리의 장소
	* 부분 문제(overlapping subproblems) : 두 번 이상 계산되는 부분 문제
	* 구현 패턴
		1. 기저 사례 처리
			* 입력이 범위를 벗어난 경우 등을 기저사례로 처리해야 함
			* 기저 사례를 확인하지 않고 cache에 접근하면 범위를 벗어나는 등의 오류가 있을 수 있음
		2. 캐시에서 해당 부분문제에 대한 값을 얻어와서 답을 구한적이 있다면 바로 반환
		3. 답을 구현한 적이 없다면 답을 구한 후 캐시에 저장하고 반환
	* 시간 복잡도 분석
		* 일반적으로, (존재하는 부분 문제의 수) X (한 부분 문제르 풀 때 필요한 반복문의 수행 횟수)
			* 위의 식은 수행시간의 상한을 간단히 계산할 수 있는 방법 일 뿐이며, 항상 정확하지 않음
			* 존재할 수 있는 모든 부분 문제 중 일부분만을 계산해도 답을 찾을 수 있는 경우에는 위의 식보다 더 작아질 수 있음
			
* 동적계획법의 사용처
	* 최적화 문제 :여러 개의 가능한 답 중 가장 좋은 답(최적해)을 찾아내는 문제
		* 최적 부분 구조 : 각 부분 문제의 최적해만 있으면 전체 문제의 최적해를 얻어낼 수 있는 구조 (지금까지 어떤 경로로 이 부분 문제에 도달했건 남은 부분 문제는 항상 최적으로 풀어도 상관없는 구조)

예제 <br/>
1. 외발 뛰기 (JUMPGAME) : solve(2017-10-07)
2. 와일드카드 (WILDCARD)
3. 삼각형 위의 최대 경로 (TRIANGLEPATH) : solve(2017-10-07)
4. 최대 증가 부분 수열 (LIS) : solve(2017-10-08)
5. 합친 LIS (JLIS)
6. 원주율 외우기 (PI)
7. Quantization(QUANTIZE)
8. 타일링 방법의 수 세기 (TILING2)
9. 삼각형 위의 최대 경로 개수 세기 (TRIPATHCNT)
10. 장마가 찾아왔다 (SNAIL)
11. 비대칭 타일링 (ASYMTILING)
12. 폴리오미노 (POLY)
13. 두니발 박사의 탈옥 (NUMB3RS)


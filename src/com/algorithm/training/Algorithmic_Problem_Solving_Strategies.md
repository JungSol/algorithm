** 알고리즘 문제해결전략 **

6장. 무식하게 풀기
* 최적화 문제 (Optimization problem)
	* 문제의 답이 하나가 아니라 여러 개이고, 그 중에서 어떤 기준에 따라 가장 좋은 답을 찾아내는 문제
	* n개의원소 중에서 r개를 순서없이 골라내는 방법의 수를 계산하는 것은 답이 하나밖에 없고, 더 좋은 답이나 덜 좋은 답이 없으므로 Optimization problem이 아님
	* n개의 사과 중에서 r개를 골라서 무게의 합을 최대화 하는 문제 or 가장 무거운 사과와 가장 가벼운 사과의 무게 차이를 최소화하는 문는 Optimization problem
	* 최적화문제를 풀기위한 가장 기초적인 것이 완전탐색 : 가능한 답을 모두 생성해 보고 그중 가장 좋은 것을 찾아냄

* 자주등장하는 완전탐색유형
	* 모든 순열 만들기
		* 서로 다른 N개의 원소를 일렬로 줄 세운 것
		* 시간복잡도 : O(N!)
		* N이 10을 넘어간다면 완전탐색에 적합하지 않음
		* c++에서는 표준 라이브러리인 STL에 포함된 next_permutation() 함수에서 모든 순열을 순서대로 생성하는 작업을 해줌
	* 모든 조합 만들기
		* 서로 다른 N개의 원소에서 R개를 순서 없이 골라낸 것
		* 시간복잡도 : 이항계수 (N R)
	* 2^N가지 경우의 수 만들기
		* N개의 질문에 대한 답이 예/아니오 중의 하나라고 할 때 존재할 수 있는 모든 조합의 수
		* 시간복잡도 : O(2^N)

예제 <br/>
1. 보글게임(BOGGLE) : solve(10/3)
2. 소풍(PICNIC) : solve(10/4) 
3. 게임판덮기(BOARDCOVER) 
4. 여행하는 외판원 문제(Traveling Sales-man Problem, TSP) : solve(10/4)
5. 시계 맞추기(CLOCKSYNC)

7장. 분할정복
* 분할 정복 알고리즘의 3가지 구성 요소
	1. divide :문제를 더 작은 문제로 분할
	2. merge : 각 묹에 대해 구한 답을 원래 문제에 대한 답으로 병합
	3. base case : 더이상 답을 분할하지 않고 곧장 풀 수 있는 매우 작은 문제

* 분할 정복 문제의 특성
	* 문제를 둘 이상의 부분문제로 나누는 자연스러운 방법이 있어야 하며,
	* 부분 문제의 답을 조합해 원래 문제의 답을 계산하는 효율적인 방법이 있어야 함
	
예제 <br/>
1. 1부터 n까지의 합 구하기(SumOfNumbers) : solve(10/5)
2. 행렬의 거듭제곱
3. 병합 정렬과 퀵 정렬
4. 카라츠바의 빠른 곱셈 알고리즘
5. 쿼드 트리 뒤집기(QUADTREE)
6. 울타리잘라내기 (FENCE)
7. 팬미팅 (FANMEETING)


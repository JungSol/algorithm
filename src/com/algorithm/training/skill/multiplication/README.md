## 고대 이집트 곱셈법 <br/>
* 출처 : https://ko.wikipedia.org/wiki/%EA%B3%A0%EB%8C%80_%EC%9D%B4%EC%A7%91%ED%8A%B8_%EA%B3%B1%EC%85%88%EB%B2%95 <br/>
* 고대 이집트 곱셈법
	* 구구단을 사용하지 않고 2로 나누고 곱하는 것과 덧셈만을 가지고 두 수를 곱하는 방법
		*  2로 곱하는 것과 덧셈, 뺄셈만을 통해 곱하기를 할 수 있다는 것이다.
	* 이집트 곱셈법과 농부 곱셈법은 첫 번째 수를 2의 거듭제곱들의 합으로 분해하고, 두 번째 수의 2의 거듭제곱에 대한 표를 만들어 첫 번째 수와 두 번째 수의 곱을 구함
* 고대 이집트 곱셈 과정
	1. 첫번째 수를 2의 거듭제곱의 합으로 분해
		* a=25 b=7이라면 25 = 16,8,1로 되어있음
	2. 1에의해 분해된 수들과 두번째수를 곱한 것의 합을 구함
		* a\*b = (16\*7) + (8\*7) + (1\*7) = 175
* 사용하는 경우
	* 모듈라 연산에서 (a\*b)%m을 해야하는데 a%m*b%m을 하더라도 오버플로우가 발생할 가능성이 있을 때
	* 속도는 일반 곱셈보다 느리지만 오버플로우 발생을 막을 수 있음
* 코드설명 (EgyptMultiplication)
	* 시간복잡도 : O(logx) (x=두 수 중 작은수)
	* 두 수중에 작은수를 x로두면 while문의 반복횟수를 줄일 수 있음
	* x를 2로 나눠주면서(>>1 비트연산 이용) 2의 거듭제곱으로 분해한다. 만약 비트가 1이면 해당 비트에 y를 곱해준값을 결과에 더해준다.
		* 여기서 비트에 y를 곱해주는 부분의 연산을 매번 반복문을 돌때마다 y에 \*2 연산을(<<1이용)해 놓아서 결과에는 그냥 y를 더해주기만 하면 되도록 한다.
		* 예를들면 loop가 2번 돌았을때 x의 맨 아래 비트가 1이면 4를 의미하며, y의 수에는 4를 곱한게 들어가 있으므로 y를 더해주면 된다.
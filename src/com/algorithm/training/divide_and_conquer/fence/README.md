## FENCE

**Difficulty:** Medium

https://algospot.com/judge/problem/read/FENCE

(사진생략) <br/>
너비가 같은 N개의 나무 판자를 붙여 세운 울타리가 있습니다. <br/>
시간이 지남에 따라 판자들이 부러지거나 망가져 높이가 다 달라진 관계로 울타리를 통째로 교체하기로 했습니다. <br/>
이 때 버리는 울타리의 일부를 직사각형으로 잘라내 재활용하고 싶습니다. <br/>
그림 (b)는 (a)의 울타리에서 잘라낼 수 있는 많은 직사각형 중 가장 넓은 직사각형을 보여줍니다. <br/>
울타리를 구성하는 각 판자의 높이가 주어질 때, 잘라낼 수 있는 직사각형의 최대 크기를 계산하는 프로그램을 작성하세요. <br/>
단 (c)처럼 직사각형을 비스듬히 잘라낼 수는 없습니다. <br/>
판자의 너비는 모두 1이라고 가정합니다. <br/><br/>

입력 <br/>
첫 줄에 테스트 케이스의 개수 C (C≤50)가 주어집니다. 각 테스트 케이스의 첫 줄에는 판자의 수 N (1≤N≤20000)이 주어집니다. 그 다음 줄에는 N개의 정수로 왼쪽부터 각 판자의 높이가 순서대로 주어집니다. 높이는 모두 10,000 이하의 음이 아닌 정수입니다. <br/><br/>

출력 <br/>
각 테스트 케이스당 정수 하나를 한 줄에 출력합니다. 이 정수는 주어진 울타리에서 잘라낼 수 있는 최대 직사각형의 크기를 나타내야 합니다. <br/>

```
Input:
3
7
7 1 5 9 6 7 3
7
1 4 4 4 4 1 1
4
1 8 2 2

Output:
20
16
8
```

**Show tag:** \#divide_and_conquer

------------------------------------

**Main : Unsolved Solution** <br/>
시간복잡도 : O(n*n) 공간복잡도 : O(1) <br/>
분할정복을 적용하지 못한 풀이 방식이다. <br/>
left, right를 이용해서 범위를 넓혀가며 최대넓이를 구하였지만, <br/>
실제로 동작은 모든 경우의수를 다 해보는 방식으로 동작한것이 문제인 것 같다. <br/>
코드의 아이디어는 다음과 같다. <br/>
범위를 한칸한칸 넓혀가는데, 매 반복마다 왼쪽으로 넓힐지 오른쪽으로 넓힐지의 결정은 넓이가 좀 더 커지는 방향으로 한다. <br/>
이렇게 해서 특정 지점에서 시작해서 최대 넓이를 찾는데 O(n)이므로 <br/>
모든 지점에서 시작해서 최대 넓이를 찾으려면 O(n*n)이 된다. <br/><br/>

**Main2** <br/>
시간복잡도 : O(nlogn) 공간복잡도 : O(1) <br/>
책의 분할 정복 알고리즘의 설계부분을 읽어보고 구현하였다. <br/>
Main의 코드를 변형시키면 되는데 <br/>
Main에서는 모든 지점에서 시작해서 n개의 판자에 대해 최대넓이를 구하여 O(n*n) 이었다. <br/>
하지만 모든 지점에서 n개의 판자에 대해 볼 필요가 없으며 <br/>
중앙지점을 기준으로 범위를 나눠서 절반씩 호출을 하면 <br/>
범위가 1/2씩 줄어들기 때문에 최대 넓이를 구하는데 O(logn)의 시간이 소요되게 된다. <br/>
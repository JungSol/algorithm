## FENCE

**Difficulty:** Medium

https://algospot.com/judge/problem/read/FENCE

(사진생략) <br/>
너비가 같은 N개의 나무 판자를 붙여 세운 울타리가 있습니다. <br/>
시간이 지남에 따라 판자들이 부러지거나 망가져 높이가 다 달라진 관계로 울타리를 통째로 교체하기로 했습니다. <br/>
이 때 버리는 울타리의 일부를 직사각형으로 잘라내 재활용하고 싶습니다. <br/>
그림 (b)는 (a)의 울타리에서 잘라낼 수 있는 많은 직사각형 중 가장 넓은 직사각형을 보여줍니다. <br/>
울타리를 구성하는 각 판자의 높이가 주어질 때, 잘라낼 수 있는 직사각형의 최대 크기를 계산하는 프로그램을 작성하세요. <br/>
단 (c)처럼 직사각형을 비스듬히 잘라낼 수는 없습니다. <br/>
판자의 너비는 모두 1이라고 가정합니다. <br/><br/>

입력 <br/>
첫 줄에 테스트 케이스의 개수 C (C≤50)가 주어집니다. 각 테스트 케이스의 첫 줄에는 판자의 수 N (1≤N≤20000)이 주어집니다. 그 다음 줄에는 N개의 정수로 왼쪽부터 각 판자의 높이가 순서대로 주어집니다. 높이는 모두 10,000 이하의 음이 아닌 정수입니다. <br/><br/>

출력 <br/>
각 테스트 케이스당 정수 하나를 한 줄에 출력합니다. 이 정수는 주어진 울타리에서 잘라낼 수 있는 최대 직사각형의 크기를 나타내야 합니다. <br/>

```
Input:
3
7
7 1 5 9 6 7 3
7
1 4 4 4 4 1 1
4
1 8 2 2

Output:
20
16
8
```

**Show tag:** \#divide_and_conquer \#stack

**Related Problem:** two\_pointers.trapping\_rain\_water

------------------------------------

**Main : Unsolved Solution** <br/>
시간복잡도 : O(n\*n) 공간복잡도 : O(1) <br/>
분할정복을 적용하지 못한 풀이 방식이다. <br/>
left, right를 이용해서 범위를 넓혀가며 최대넓이를 구하였지만, <br/>
실제로 동작은 모든 경우의수를 다 해보는 방식으로 동작한것이 문제인 것 같다. <br/>
코드의 아이디어는 다음과 같다. <br/>
범위를 한칸한칸 넓혀가는데, 매 반복마다 왼쪽으로 넓힐지 오른쪽으로 넓힐지의 결정은 넓이가 좀 더 커지는 방향으로 한다. <br/>
이렇게 해서 특정 지점에서 시작해서 최대 넓이를 찾는데 O(n)이므로 <br/>
모든 지점에서 시작해서 최대 넓이를 찾으려면 O(n\*n)이 된다. <br/><br/>

**Main2 : Using Devide And Conquer** <br/>
시간복잡도 : O(nlogn) 공간복잡도 : O(1) <br/>
책의 분할 정복 알고리즘의 설계부분을 읽어보고 구현하였다. <br/>
Main의 코드를 변형시키면 되는데 <br/>
Main에서는 모든 지점에서 시작해서 n개의 판자에 대해 최대넓이를 구하여 O(n*n) 이었다. <br/>
하지만 모든 지점에서 n개의 판자에 대해 볼 필요가 없으며 <br/>
중앙지점을 기준으로 범위를 나눠서 절반씩 호출을 하면 <br/>
범위가 1/2씩 줄어들기 때문에 최대 넓이를 구하는데 O(logn)의 시간이 소요되게 된다. <br/>

**Best Main : Using stack** <br/>
시간복잡도 : O(n) 공간복잡도 : O(n) <br/>
i번 판자를 완전히 포함하는 사각형 중 면적이 최대인 사각형을 n개에 대해 모두 구하여 최대 넓이를 구하면 된다.
특정 판자의 최대 사각형은 아래와 같은 특징을 가진다. <br/>
* 이 사각형의 높이는 i번 판자의 높이와 같다.
* 이 사각형의 왼쪽 끝과 오른쪽 끝은 i번 판자보다 낮은 판자로 막혀있다.(이 사각형을 막는 판자들의 번호를 각각 left[i], right[i]라고 지칭)
* left[i]와 right[i]를 알고 있다면 사각형의 넓이는 (right[i]-left[i]-1)*height[i]가 된다.

구체적인 구현은 아래와 같다. <br/>
stack에 판자들을 넣는데 i번째 판자에대해 아래와 같은 행동을 취한다. <br/>
1. i번째 판자의 높이가 스택에 제일 위에있는(최근에 들어온) 판자 j의 높이보다 클 경우
	* j번쨰 판자의 최대사각형은 left[j]는 알고있지만(스택에서 j 바로 밑에있는 판자), right[j]는 아직 알 수 없다.
	* i번째 판자의 최대사각형은 j에 의해 막혀있는 것이므로 left[i] = j가 되는데 right[i]는 알 수 없다.
	* 따라서 i번째 판자를 스택에 넣고 계속 진행한다.
2. i번째 판자의 높이가 스택에 제일 위에있는(최근에 들어온) 판자 j의 높이보다 작을 경우
	* j번째 판자의 최대사각형은 i번쨰 판자에의해 오른쪽이 막혔으므로 최대사각형의 왼쪽과 오른쪽이 모두 정의가 되기 떄문에 넓이를 구할 수 있다.
		* 이를 스택에 있는 판자들에 대해 반복해서 수행하며 i번째 판자에 의해 오른쪽이 막히지 않을때까지 진행한다.
	* 위의 과정을 반복하고 나면 i번째 판자의 최대사각형은 스택에 남은 판자중에 제일 위에 있는 판자에 의해 왼쪽이 막혀있는 것이므로 left[i] = stack.peek()가 되는데 right[j]는 알 수 없다.
	* 따라서 i번째 판자를 스택에 넣고 계속 진행한다.
3. i번째 판자의 높이가 스택에 제일 위에있는(최근에 들어온) 판자 j의 높이랑 같을 경우
	* i번째 판자의 최대 사각형은 j번째 판자의 최대사각형에 포함된다. 따라서 stack에서 j번째 판자를 제거하면 된다.
	* 2번과 완전히 동일하게 행동해도 상관 없다.
		* 스택에서 j판자를 제거만 해도 괜찮고, 제거하고 넓이를 구하는 2번작업을 해도 상관없다. 어차피 넓이는 i판자가 stack에서 제거될때 갱신될 것이다.

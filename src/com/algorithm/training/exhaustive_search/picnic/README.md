## PICNIC

**Difficulty:** Easy

https://algospot.com/judge/problem/read/PICNIC

안드로메다 유치원 익스프레스반에서는 다음 주에 율동공원으로 소풍을 갑니다. <br/>
원석 선생님은 소풍 때 학생들을 두 명씩 짝을 지어 행동하게 하려고 합니다. <br/>
그런데 서로 친구가 아닌 학생들끼리 짝을 지어 주면 서로 싸우거나 같이 돌아다니지 않기 때문에, 항상 서로 친구인 학생들끼리만 짝을 지어 줘야 합니다. <br/>
각 학생들의 쌍에 대해 이들이 서로 친구인지 여부가 주어질 때, 학생들을 짝지어줄 수 있는 방법의 수를 계산하는 프로그램을 작성하세요. <br/>
짝이 되는 학생들이 일부만 다르더라도 다른 방법이라고 봅니다. <br/>
예를 들어 다음 두 가지 방법은 서로 다른 방법입니다. <br/>

* (태연,제시카) (써니,티파니) (효연,유리)
* (태연,제시카) (써니,유리) (효연,티파니)

입력 <br/>
입력의 첫 줄에는 테스트 케이스의 수 C (C <= 50) 가 주어집니다. <br/>
각 테스트 케이스의 첫 줄에는 학생의 수 n (2 <= n <= 10) 과 친구 쌍의 수 m (0 <= m <= n*(n-1)/2) 이 주어집니다. <br/>
그 다음 줄에 m 개의 정수 쌍으로 서로 친구인 두 학생의 번호가 주어집니다. <br/>
번호는 모두 0 부터 n-1 사이의 정수이고, 같은 쌍은 입력에 두 번 주어지지 않습니다. <br/>
학생들의 수는 짝수입니다. <br/><br/>

출력 <br/>
각 테스트 케이스마다 한 줄에 모든 학생을 친구끼리만 짝지어줄 수 있는 방법의 수를 출력합니다. <br/>

```
Input:
3 
2 1 
0 1 
4 6 
0 1 1 2 2 3 3 0 0 2 1 3 
6 10 
0 1 0 2 1 2 1 3 1 4 2 3 2 4 3 4 3 5 4 5

Output: 
1
3
4
```

**Note:**

**Show tag:** \#exhaustive\_search

------------------------------------

**Main** <br/>
시간복잡도 : O(n!) 공간복잡도(O(Math.max(n,m)) n=학생수, m=친구쌍수 <br/>
Set에 친구쌍을 저장해놓고 모든 경우의수를 다 따져가면서 서로 친구이면 매칭시키고 아니면 패스하면서, <br/>
모든 학생들이 매칭이되었는지 확인하는 방식으로 해결하였다. <br/>

**Main2** <br/>
Main이랑 로직은 동일하나 책을 참고하여 리펙토링한 코드이다.
친구쌍을 매칭시킬때 작은 index의 친구에서 출발하므로 Main코드에서 사용하였던 <br/>
Set에서 해당 학생두명이 친구인지 아닌지를 확인할때 Math.min, Math.max 함수를 제거할 수 있다. <br/>

단 (1,2)와 (2,1)은 같은 친구쌍이므로 중복처리를 위해서, <br/>
친구쌍을 매칭시킬 때 더 작은 index인 친구의 index+1부터 매칭이 되지 않은 친구를 찾아서 (코드43줄) 중복처리를 방지하였다. <br/>
(참고로 traveling\_salesman\_problem 경우에는 1->2와 2->1 이 다르므로 코드는 비슷하지만 0부터 시작한다.)
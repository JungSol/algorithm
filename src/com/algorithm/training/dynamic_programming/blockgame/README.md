## BLOCKGAME

**Difficulty:** Medium

https://algospot.com/judge/problem/read/BLOCKGAME

시티빌과 비주얼드에 지친 진호와 현환이는 집에 굴러다니는 블럭들을 모아 새로운 게임을 하기로 했습니다. <br/>
5×5 크기의 게임판에서 시작해, 둘이 번갈아 가며 블럭을 하나씩 게임판에 내려놓습니다. <br/>
블럭은 L 모양으로 구성된 3칸짜리 블럭과 2칸짜리 블럭이 있으며, 항상 게임판에 있는 줄에 맞춰 내려놓아야 합니다. <br/>
블럭들은 서로 겹칠 수 없습니다. <br/>
다음 그림은 진행중인 게임판의 모습을 보여줍니다. <br/>

(그림생략) <br/>

그림에서 보이는 바와 같이 각 블록은 자유롭게 뒤집거나 회전해서 올려놓을 수 있습니다. <br/>
두 사람이 번갈아가며 블록을 올려놓다가 더 올려놓을 수 없게 되면 마지막에 올려놓은 사람이 승리합니다. <br/>
진행 중인 게임판이 주어질 때 이번 차례인 사람이 승리할 수 있는 방법이 있는지를 판단하는 프로그램을 작성하세요.

입력 <br/>
입력의 첫 줄에는 테스트 케이스의 수 C (C≤50)가 주어집니다. 각 테스트 케이스는 다섯 줄에 각 다섯 개의 문자로 구성되며, #는 이미 블록이 놓인 칸, 마침표(.)는 블록이 없는 칸을 의미합니다.

출력 <br/>
각 테스트 케이스마다 한 줄을 출력합니다. 이번 차례인 사람이 항상 이길 수 있는 방법이 있다면 WINNING을, 항상 질 수밖에 없다면 LOSING을 출력합니다.

```
Input:
1
#..##
##.##
##.##
#...#
##.##
.....
.##..
##..#
#.###
..#..
.....
.....
.....
.....
.....
#..##
##.##
##.##
#...#
##.##

Output: 
WINNING
LOSING
WINNING
```

**Note:**

**Show tag:** \#dynamic\_programming

------------------------------------

**Main** <br/>
시간복잡도 : O(2^n * n) 공간복잡도 : O(2^n) (n=board의 크기인 25) <br/>
_시간복잡도 정확하게 모르겠다_ <br/>
_해당 코드는 여러번 제출할 경우 가끔씩 TLE가 발생하기도 한다. 매우 느리다._ <br/>

boardState에는 25bit에 5x5보드의 상태를 저장해둔다. <br/>
isWin(int boardState)메소드를 현재 보드 상태가 주어질 때 이번판 플레이어가 이길 수 있는지를 반환하도록 정의한다. <br/>
해당 함수에서는 5x5 보드를 순회하면서 비어있는 지점이 있다면 setBlock() 메소드를 호출하여 block을 놓아서 이길 수 있는지를 확인한다. <br/>

setBlock(int boardState, int cX, int cY)메소드는 보드의 상태가 주어지고 현재위치가 (cX,cY)일 때 block을 놓아서 이길 수 있는지를 확인한다. <br/>
블럭은 총 6가지가 있으므로 해당 경우들을 모두 만들어보면서, <br/>
해당 블럭이 보드판을 벗어나지 않고, 놓고자 하는 위치가 비어있다면 해당 블록을 놓고 보드상태를 변경하여 재귀호출한다. <br/>
이를 반복하여 이길 수 있는 경우가 단 한번이라도 있는지를 확인하여 결과값으로 사용한다. <br/>

이 문제를 풀면서 제출했을 때 런타임에러를 굉장히 많이 만났는데 아래와 같은 이유였다. <br/>
1. 이번 문제에서는 캐시가 재활용이 가능하다. 그러므로 캐시는 한번만 선언 및 초기화 하면 된다.
2. 캐시의 자료형을 int로 하면 메모리가 초과되며, 캐시안에는 -1,0,1만 저장되므로 byte로 선언한다.
3. 매 경기마다 플레이어는 최선을 다하므로 재귀호출을 할 때 이길 수 있는 경우가 한번이라도 발생하면 탐색을 중단한다.
## GRADUATION

**Difficulty:** Medium

https://algospot.com/judge/problem/read/GRADUATION

1학년은 노는 게 남는 거란 선배의 말을 철석같이 믿고, 전공 과목은 다 수강철회하고 교양 과목은 다 F 받는 방탕한 1학년을 보냈던 태우는 이제 와서 자신의 행동을 후회하고 있습니다. <br/>
졸업 전에 채워야 할 학점이 너무 많기 때문입니다. <br/>
졸업 필수 학점을 채우려면 전공 과목 N 개 중 K 개 이상을 수강해야 합니다. <br/>
그런데 각 과목은 해당 과목의 선수과목을 미리 수강했어야만 수강할 수 있으며, 각 학기마다 모든 과목이 개설되는 것이 아니기 때문에 문제가 복잡해졌습니다. 어떻게 해야 최소 학기에 졸업을 할 수 있을까요? <br/>

각 과목의 정보와 앞으로 M 학기 동안 개설될 과목의 목록이 주어질 때, 태우가 최소 몇 학기를 다녀야 졸업할 수 있는지 계산하는 프로그램을 작성하세요. <br/>
한 과목도 수강하지 않는 학기는 휴학한 것으로 하며, 다닌 학기 수에 포함되지 않습니다.

입력 <br/>
입력의 첫 줄에는 테스트 케이스의 수 C (C <= 50) 가 주어집니다. 각 테스트 케이스의 첫 줄에는 전공 과목의 수 N (1 <= N <= 12), 들어야 할 과목의 수 K (0 <= K <= N), 학기의 수 M (1 <= M <= 10) 과 태우가 한 학기에 최대로 들을 수 있는 과목의 수 L (1 <= L <= 10)이 주어집니다. 각 과목에는 0부터 N-1 까지의 번호가 매겨져 있습니다. <br/>
그 후 N 줄에 0번 과목부터 순서대로 각 과목의 정보가 주어집니다. 이 줄에는 해당 과목의 선수 과목의 수 Ri (0 <= Ri <= N-1) 가 처음 주어지고, 그 후 Ri 개의 정수로 선수 과목의 번호가 주어집니다. <br/>
그 후 M 줄에는 이번 학기부터 순서대로 각 학기의 정보가 주어집니다. 각 줄에는 해당 학기에 개설되는 과목의 숫자 Ci (1 <= Ci <= 10) 가 주어지고, 그 후 Ci 개의 정수로 개설되는 과목의 번호들이 주어집니다. <br/>

출력 <br/>
각 테스트 케이스마다 한 줄에 태우가 다녀야 할 최소 학기 수를 출력합니다. M 학기 내에 졸업할 수 없는 경우 IMPOSSIBLE을 출력합니다.

```
Input:
2
4 4 4 4
0
1 0
3 0 1 3
0
4 0 1 2 3 
4 0 1 2 3
3 0 1 3
4 0 1 2 3
4 2 2 4
1 1
0
1 3
1 2
3 0 2 3
3 1 2 3

Output: 
3
IMPOSSIBLE
```

**Note:**

**Show tag:** \#dynamic\_programming \#bit\_mask

------------------------------------

**Main** <br/>
시간복잡도 : O(m\*2^(n+c)) 공간복잡도 : O(m\*2^n) (m=학기의 수, n=과목의 수, c=학기에 개설 되는 과목 수) <br/>
해당 문제의 부분문제의 개수는 m \* 2^n이며, <br/>
부분문제에서 listen의 모든 부분집합을 순회하는데 최대 2^c만큼 걸리므로 시간복잡도는 위와 같고, <br/>
이는 최악의 경우에 약 4천만정도로 충분히 계산 가능하다. <br/>
getMinSemester(int listen, int currentSemester, int reaminedSubjectCount)를 현재 cureentSemester학기이고, listen에 표시된 과목들을 수강하였으며 remainedSubjectCount개수만큼의 과목을 더 수강해야 할때의 최소학기를 구하는 메소드로 정의한다. <br/>
기저사례는 2가지가 있다. <br/>
1. 만약 remainedSubjectCount가 0이하이면 모든 과목을 들은 것이므로 0을 리턴한다.
2. 다닐수 있는 학기를 넘어서면 INF(나는 maxSemester+1로 하였다)값을 리턴한다.

최소학기를 구하는 단계는 아래와 같다. <br/>
1. 현재학기에서 수강할 수 있는 과목 list를 받아온다. (bit mask연산을 이용해서 int에 저장되어있다.)
2. 반복문을 이용하여 해당 과목들로 만들 수 이는 모든 부분집합을 구한다.
3. 반복문 내부에서는 해당 부분집합을 수강할 수 있는지를 확인하여 수강할 수 있다면 카운트를 1세주고 재귀호출로 다음학기를 호출한다.
	1. 부분집합의 과목들의 개수는 한학기에 들을 수 있는 과목의 개수 이하여야 한다.
	2. 부분집합의 과목들은 모두 아직 듣지 않았어야 한다.
	3. 부분집합의 과목들의 선이수과목들은 모두 들었어야 한다.
4. 해당 학기에 휴학을 하는 경우도 고려해야 하므로 아무런 과목도 수강하지 않고 다음 학기로 넘어가는 메소드를 재귀호출 한다.
5. 위의 과정을 반복하며 최소학기를 구해준다.

**고민해봐야 할 것(TODO)**
선이수 과목 리스트와 학기 별 들을수있는 과목 리스트의 bit mask를 만들어 줄 때 산술연산으로 하면 결과가 wrong answer로 나오는데, 정확한 이유를 잘 모르겠다.

**Main2** <br/>
시간복잡도 : O(m\*2^(n+c)) 공간복잡도 : O(m\*2^n) (m=학기의 수, n=과목의 수, c=학기에 개설 되는 과목 수) <br/>
Main코드를 리펙토링 한 것이므로 기본 로직은 동일하다. <br/>
1. Main에서는 getMinSemester함수에서 남은 과목의 개수인 remainedSubjectCount를 파라메터로 사용했었는데 이를 제거하고 countSubject함수를 이용하였다.
2. Main에서는 해당학기에 개설된 과목들의 모든 부분집합을 순회하면서 각 부분집합을 정말로 수강할 수 있는지를 확인하는 방법으로 순회하였는데, Main2에서는 개설된 과목들 중 들을 수 없는 과목들은 모두 제외시킨 후 걸러진 과목들의 부분집합을 순회한다.
3. 선이수과목리스트와 학기별들을수있는과목리스트를 입력받을 때 map을 사용하였는데 배열을 사용하도록 변경하였다.
## TRIPATHCNT

**Difficulty:** Medium

https://algospot.com/judge/problem/read/TRIPATHCNT

9 <br/>
5 7 <br/>
1 3 2 <br/>
3 5 5 6 <br/>
위 형태와 같이 삼각형 모양으로 배치된 자연수들이 있습니다. <br/>
맨 위의 숫자에서 시작해, 한 번에 한 칸씩 아래로 내려가 맨 아래 줄로 내려가는 경로를 만들려고 합니다. <br/>
경로는 아래 줄로 내려갈 때마다 바로 아래 숫자, 혹은 오른쪽 아래 숫자로 내려갈 수 있습니다. <br/>

이 때 숫자의 합이 가장 큰 경로는 하나가 아니라 여러 개일 수 있습니다. <br/>
예를 들어 위 삼각형에서는 {9, 7, 2, 6}과 {9, 7, 3, 5}의 합이 모두 최대인 24이고, {9, 7, 3, 5}는 두 번 등장하거든요. <br/>

삼각형이 주어질 때 최대 경로의 수를 세는 프로그램을 작성하세요. <br/>

입력 <br/>
입력의 첫 줄에는 테스트 케이스의 수 C(C <= 50)가 주어집니다. 각 테스트 케이스의 첫 줄에는 삼각형의 크기 n(2 <= n <= 100)이 주어지고, 그 후 n줄에는 각 1개~n개의 숫자로 삼각형 각 가로줄에 있는 숫자가 왼쪽부터 주어집니다. 각 숫자는 1 이상 100000 이하의 자연수입니다.

출력 <br/>
각 테스트 케이스마다 한 줄에 최대 경로의 수를 출력합니다. 
경로의 수는 2^30 이하라고 가정해도 좋습니다.

```
Input:
2
4
1
1 1 
1 1 1 
1 1 1 1 
4
9
5 7
1 3 2
3 5 5 6

Output: 
8
3
```

**Note:**

**Show tag:** \#dynamic\_programming

------------------------------------

**Solution** <br/>
시간복잡도 : O(n^2) 공간복잡도 : O(n^2) <br/>
TRIANGLEPATH 문제에서 dp를 이용하여 maxPathLength를 구하였다. <br/>
해당 문제의 로직을 그대로 이용하여 maxPath[i][j] 배열에 (i,j)에서 출발하여 이동하며 맨 마지막줄 까지 도달할때 까지의 경로의 최대값을 저장해둔다. <br/>
그 후 경로의 최대값의 count를 세는 작업을 아래처럼 dp를 이용하여 한다. <br/>
하나의 점에서는 두개로 내려갈 수 있는데 (i,j)점을 기준으로 <br/>
1. maxPath[i+1][j] > maxPath[i+1][j+1] : maxPathLength를 얻기 위해서는 (i+1,j+1)로는 내려갈 필요가 없으므로 (i+1,j)로만 내려간다.
2. maxPath[i+1][j] < maxPath[i+1][j+1] : maxPathLength를 얻기 위해서는 (i+1, j)로는 내려갈 필요가 없으므로 (i+1, j+1)로만 내려간다.
3. maxPath[i+1][j] == maxPath[i+1][j+1] : maxPathLength를 얻기 위해서는 (i+1, j), (i+1, j+1) 둘 다 내려간다.
시간복잡도 O(n^2)의 연산을 두번하게 된다.
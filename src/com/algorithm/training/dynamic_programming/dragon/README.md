## DRAGON

**Difficulty:** Medium

https://algospot.com/judge/problem/read/DRAGON

(그림생략)

드래곤 커브(Dragon curve)는 간단한 수학 규칙으로 그릴 수 있는 그림으로, 위 그림같은 형태를 지닙니다. <br/>
드래곤 커브는 선분 하나에서 시작해서 간단한 규칙으로 이 선분을 변형해서 만들어지며, 변형이 한 번 이루어져 세대가 변할 때마다 더욱 복잡한 모양으로 진화합니다. <br/>
이 도형같이 일부를 확대했을 때 전체와 비슷한 형태로 구성된 도형들을 프랙탈(fractal) 이라고 하지요. <br/>

드래곤 커브를 그리는 방법을 드래곤 커브 문자열이라고 부릅시다. <br/>
드래곤 커브 문자열은 X, Y, F, +, -로 구성된 문자열인데, 우리는 한 점에서 시작해 다음과 같이 커브를 그리면 됩니다.
* F: 앞으로 한 칸 전진하며 선을 긋습니다.
* +: 왼쪽으로 90도 회전합니다.
* -: 오른쪽으로 90도 회전합니다.
* X, Y: 무시합니다.

0세대 드래곤 커브를 그리는 문자열은 선분 하나인 FX 입니다.  <br/>
그리고 그 이후의 다음 세대는 이전 세대 문자열의 각 글자를 다음과 같이 치환해서 만들어집니다. <br/>
* X => X+YF
* Y => FX-Y

따라서 1, 2세대 드래곤 커브 문자열은 다음과 같습니다. <br/>
* 1세대: FX+YF
* 2세대: FX+YF+FX-YF

n세대 드래곤 커브 문자열을 구하고 싶습니다. <br/>
이 때 문자열 전체를 구하면 너무 기니, 문자열 중 p번째 글자부터 l글자만을 계산하는 프로그램을 작성하세요. <br/>

입력 <br/>
입력의 첫 줄에는 테스트 케이스의 수 c (c <=50) 가 주어집니다. 각 테스트 케이스의 첫 줄에는 세 개의 정수로 드래곤 커브의 세대 n (0 <= n <= 50) , 그리고 p 와 l (1 <= p <= 1,000,000,000 , 1 <= l <= 50) 이 주어집니다. n세대의 드래곤 커브 문자열의 길이는 항상 p+l 이상이라고 가정해도 좋습니다.

출력 <br/>
각 테스트케이스마다 한 줄에 n세대 드래곤 커브 문자열의 p번째 글자부터 l글자를 출력합니다.

```
Input:
4
0 1 2
1 1 5
2 6 5
42 764853475 30 

Output: 
FX 
FX+YF 
+FX-Y 
FX-YF-FX+YF+FX-YF-FX+YF-FX-YF- 
```

**Note:**

**Show tag:** \#dynamic\_programming

------------------------------------

**BestMain** <br/>
시간복잡도 : O(n*l) 공간복잡도 : O(1) n=세대, l=글자개수 <br/>
알고리즘 문제해결전략 책의 풀이(309p)를 보고 구현하였다. <br/>
length배열의 i인덱스에 X와 Y를 i세대 진화시켰을때 문자열의 길이를 미리 계산해서 넣어둔다. <br/>
XLength[i] = xLength[i-1] + yLength[i-1] + 2 <br/>
yLength[i] = xLength[i-1] + yLength[n-1] + 2 <br/>
즉 xLength[i] = yLength[i] 이므로, <br/>
length[i] = 2 + 2 * length[i-1]로 정리할 수 있다. <br/>
getKthDragonCurve(String str, int generation, int k)을 str을 generation세대만큼 진화시킬 때 k번째 글자를 반환하는 함수로 정의한다. <br/>
str의 문자를 순회하면서 X이거나 Y이면 해당 문자를 generation 세대만큼 진화시켰을때의 문자열의 길이를 미리 구해둔 length 배열에서 얻는다. <br/>
길이가 k보다 작으면 해당 문자를 generation 세대만큼 진화시켰을 때의 문자열에는 k번째 문자가 포함되지 않는것이므로 k를 줄이고 다음 문자로 넘어간다. <br/>
길이가 k랑 같거나 크면 해당 문자를 generation 세대만큼 진화시켰을 때의 문자열에는 k번째 문자가 포함된다는 것이기 때문에 해당문자를 1세대 진화시킨 후 재귀호출을 반복하며 k번째 문자를 찾는다.
generation세대까지 계속 진화시킨 후 generation이 0이되었을 떄의 k번째 문자가 찾고자하는 문자이게 된다. <br/>
반면 str의 문자가 X랑 Y가 아니면 k가 1일경우 해당 문자를 반환 하고 1이 아닐경우 k를 하나 줄이고 다음 문자로 넘어가면 된다.

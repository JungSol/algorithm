## Service of Eratosthenes (에라토스테네스의 체)

**Difficulty:** Easy

알고리즘 문제해결 전략 498p 예제

주어진 자연수 n이 소수인지 판별한다.

**Note:**

**Show tag:** \#number\_theory

----------------------------------------------

**Solution** <br/>
시간복잡도 : O(n*loglogn) 공간복잡도 : O(n) <br/>
에라토스테네스의 체의 시간복잡도는 계산하기 까다로운데, 내부 반복문이 얼마나 실행될지는 [1, 루트n]범위 내에 소수가 어떤 분포로 출현하는지에 따라 달라지기 때문이다. <br/>
소수의 분포를 근사값으로 표현하는 기법을 사용하면, 필요한 전체 연산의 수가 O(nloglogn)임을 증명할 수 있다. <br/>
_해당 증명은 정수론의 소수 정리(Prime Nubmer Teorem)를 이용_ <br/>
loglogn은 굉장히 느리게 증가하는 함수이기 때문에(64비트 정수형에 들어가는 최대 수에 대해서도 4를 넘지 않음) 실용적인 범위 내에서 수행시간은 거의 O(n)과 비슷하다고 생각 할 수 있다.

에라토스테네스의 체를 구현은 빠르지만 문제가 되는것은 메모리 사용량이다. <br/>
많은 수에 대해 에라토스테네스의 체를 수행해야 할 떄는 짝수를 별도로 처리해서 필요한 배열의 크기를 절반으로 줄이거나, 비트마스크를 사용하는 기법이 필요하다.

n+1크기의 boolean 배열에 소수인지(true) 아닌지(false)를 저장한다.
0과 1에 대해서는 예외처리를 해 주고, <br/>
2부터 n까지 반복문을 순회하며 아직 지워지지 않은 수라면 그 수는 소수이며, <br/>
해당 수의 배수들은 모두 합성수이므로 false로 변경하여 소수목록을 얻는다.

목록에서 지워지지 않은 수 i의 배수들을 제거할 때 for루프를 사용하는데, <br/>
루프의 반복변수의 초기값을 i\*2가 아닌 i\*i로 하면 내부 for문의 반복횟수를 줄일 수 있다. <br/>
i\*i 미만의 i의 배수는 이미 i보다 작은 소수로 인해 지워진 상태이므로 i\*i부터 보면 된다.
## TILING2

**Difficulty:** Easy

https://algospot.com/judge/problem/read/TILING2

2xn 크기의 사각형을 2x1 크기의 사각형으로 빈틈없이 채우는 경우의 수를 구하는 프로그램을 작성하세요. <br/>
예를 들어 n=5라고 하면 다음 그림과 같이 여덟 가지의 방법이 있습니다. <br/>
(그림 생략) <br/>
경우의 수는 n이 커지면 아주 커질 수 있으므로, 1000000007으로 나눈 값을 대신 출력하세요.

입력 <br/>
입력의 첫 줄에는 테스트 케이스의 수(C <= 50)가 주어집니다. 그후 C줄에 각각 1개의 자연수로 n(1 <= n <= 100)이 주어집니다.

출력 <br/>
각 테스트 케이스마다 한 줄에 경우의 수를 1000000007로 나눈 나머지를 출력합니다.

```
Input:
3
1
5
100

Output: 
1
8
782204094
```

**Note:**

**Show tag:** \#dynamic\_programming

------------------------------------

**Solution** <br/>
시간복잡도 : O(n) 공간복잡도 : O(n) <br/>
타일링을 하는것은 1개의 세로타일을 이용해서 덮거나(2x1사이즈) 2개의 가로타일을 이용해서 덮거나(2x2사이즈) 덮는 두 가지 방법 뿐이다. <br/>
해당 속성은 다음과 같은 2가지의 조건을 모두 충족하므로 매 단계마다 세로줄을 세로 타일 하나로 덮을지, 가로줄을 가로 타일 두개로 덮을지만 결정하면 된다. <br/>
* 이 두가지 분류는 타일링 하는 방법을 모두 포함한다.
* 두가지 분류에 모두 포함되는 타일링 방법은 없다.
getTilingCount(int n)은 2xn크기의 사각형을 타일로 덮는 방법을 의미한다. <br/>

오버플로우에 대한 고민 <br/>
getTilingCount 메소드가 반환하는 최대치는 MOD_VALUE(1000000007)-1 = 1000000006인데, <br/>
메소드 내부에서 이 값을 두번까지 더하는 로직이 있는데 1000000006 * 2 = 2000000012인데, <br/>
이는 2^31-1(2147483647)을 넘어가지 않으므로 중간 값 오버플로우가 발생하지 않는다.

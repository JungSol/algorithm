## Service of Eratosthenes (에라토스테네스의 체)

**Difficulty:** Easy

알고리즘 문제해결 전략 498p 예제

주어진 자연수 n이하의 소수리스트를 반환한다.

**Note:**

**Show tag:** \#number\_theory \#bit\_manipulation

----------------------------------------------

**Solution** <br/>
시간복잡도 : O(n*loglogn) 공간복잡도 : O(n) <br/>
에라토스테네스의 체의 시간복잡도는 계산하기 까다로운데, 내부 반복문이 얼마나 실행될지는 [1, 루트n]범위 내에 소수가 어떤 분포로 출현하는지에 따라 달라지기 때문이다. <br/>
소수의 분포를 근사값으로 표현하는 기법을 사용하면, 필요한 전체 연산의 수가 O(nloglogn)임을 증명할 수 있다. <br/>
_해당 증명은 정수론의 소수 정리(Prime Nubmer Teorem)를 이용_ <br/>
loglogn은 굉장히 느리게 증가하는 함수이기 때문에(64비트 정수형에 들어가는 최대 수에 대해서도 4를 넘지 않음) 실용적인 범위 내에서 수행시간은 거의 O(n)과 비슷하다고 생각 할 수 있다.

n+1크기의 boolean 배열에 소수인지(true) 아닌지(false)를 저장한다.
0과 1에 대해서는 예외처리를 해 주고, <br/>
2부터 n까지 반복문을 순회하며 아직 지워지지 않은 수라면 그 수는 소수이며, <br/>
해당 수의 배수들은 모두 합성수이므로 false로 변경하여 소수목록을 얻는다.

목록에서 지워지지 않은 수 i의 배수들을 제거할 때 for루프를 사용하는데, <br/>
루프의 반복변수의 초기값을 i\*2가 아닌 i\*i로 하면 내부 for문의 반복횟수를 줄일 수 있다. <br/>
i\*i 미만의 i의 배수는 이미 i보다 작은 소수로 인해 지워진 상태이므로 i\*i부터 보면 된다.

**Best Solution (Using bit mask)** <br/>
알고리즘 문제해결 전략2의 586p 코드를 보고 구현하였다. <br/>
책에서는 1byte 비트마스크를 사용하여 메모리를 1/8로 줄였지만 나는 2byte를 기준으로 구현해보았다. <br/>

isPrime배열의 각 숫자는 16개의 수에 대해 소수인지 아닌지를 가지고 있다. <br/>
각 비트의 자리가 1이면 소수인 것이고 0이면 합성수인것이다. <br/>
k 원소가 참인지를 알기 위해서는 isPrime[k/16]의 k%16비트가 켜져있는지를 확인하면 된다. <br/>
(k/16은 k >> 4로 표현가능하며, k%16은 k & 15로 표현 가능하다.)

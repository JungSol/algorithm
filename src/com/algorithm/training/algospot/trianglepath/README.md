## TRIANGLEPATH

**Difficulty:** Easy

https://algospot.com/judge/problem/read/TRIANGLEPATH

6 <br/>
1  2 <br/>
3  7  4 <br/>
9  4  1  7 <br/>
2  7  5  9  4 <br/>
위 형태와 같이 삼각형 모양으로 배치된 자연수들이 있습니다. <br/>
맨 위의 숫자에서 시작해, 한 번에 한 칸씩 아래로 내려가 맨 아래 줄로 내려가는 경로를 만들려고 합니다. <br/>
경로는 아래 줄로 내려갈 때마다 바로 아래 숫자, 혹은 오른쪽 아래 숫자로 내려갈 수 있습니다. <br/>
이 때 모든 경로 중 포함된 숫자의 최대 합을 찾는 프로그램을 작성하세요. <br/>

입력 <br/>
입력의 첫 줄에는 테스트 케이스의 수 C(C <= 50)가 주어집니다. 각 테스트 케이스의 첫 줄에는 삼각형의 크기 n(2 <= n <= 100)이 주어지고, 그 후 n줄에는 각 1개~n개의 숫자로 삼각형 각 가로줄에 있는 숫자가 왼쪽부터 주어집니다. 각 숫자는 1 이상 100000 이하의 자연수입니다.

출력 <br/>
각 테스트 케이스마다 한 줄에 최대 경로의 숫자 합을 출력합니다.

```
Input:
2
5
6
1  2
3  7  4
9  4  1  7
2  7  5  9  4
5
1 
2 4
8 16 8
32 64 32 64
128 256 128 256 128

Output: 
28
341
```

**Note:**

**Show tag:** \#dynamic\_programming

**Related Problem:** dynamic\_programming.triangle

------------------------------------

**Solution : Using Recursion** <br/>
시간복잡도 : O(n^2) 공간복잡도 : O(n^2) <br/>
아래쪽 혹은 오른쪽 아래로 내려갈 수 있으므로 (x,y)지점에서 두 경우를 모두 재귀호출하여 <br/>
최대합을 가지는 경로를 구할 수 있다.

**Best Solution : Using Iterative** <br/>
시간복잡도 : O(n^2) 공간복잡도 : O(n) <br/>
재귀호출을 이용한 dp에서 반복문을 이용한 dp로 변경하였다. <br/>
dp\[i\]\[j\]는 (i,j)로 내려오는 최대 length로 정의하는데 이는 바로위 혹은 왼쪽위의 지점에서 내려올 수 있으므로, <br/>
max(dp\[i-1\]\[j-1\], dp\[i-1\]\[j\]) + board\[i\]\[j\]로 정의할 수 있다. <br/>

이런식으로 반복문을 이용해서 답을 구하는데 공간복잡도를 줄이기 위해서 슬라이딩 윈도 기법을 사용하였다. <br/>
dp\[i\]\[\]를 구할 떄 dp\[i-1\]\[\]만 사용하므로 모든 행을 다 저장할 필요 없이 직전행과 현재행만 가지고 있으면 된다. <br/>
따라서 2*n크기의 행렬을 선언한 후 행을 번갈아가변서 사용하여 동적계획법을 수행한다. <br/>
행을 번갈아가면서 사용하는 것은 2로 나눈 나머지를 이용한다.

**Best Solution2 : Using Iterative** <br/>
시간복잡도 : O(n^2) 공간복잡도 : O(n) <br/>
Best Solution의 변형 및 개선이다. <br/>
최대 길이의 경로를 구할 때 주어진 행렬의 (0,0)에서 시작하여 아래까지 쭉 내려가서 바닥에 n개의 수가 있는데, <br/>
이를 다 비교해서 구한 최대값이 최종적인 최대 경로 길이가 된다. <br/>
그런데 만약 아래에서부터 위로 올라간다면 수를 비교하여 최대값을 얻지 않아도 (0,0)지점에 도착하였을 때의 값이 최종적인 최대 경로 길이가 된다. <br/>
따라서 Best Solution2는 위에서 아래로 탐색하던 Best Solution을 아래에서 위로 탐색하도록 변경한 것이다.

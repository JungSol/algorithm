6장. 무식하게 풀기

* 최적화 문제 (Optimization problem)
	* 문제의 답이 하나가 아니라 여러 개이고, 그 중에서 어떤 기준에 따라 가장 좋은 답을 찾아내는 문제
	* n개의원소 중에서 r개를 순서없이 골라내는 방법의 수를 계산하는 것은 답이 하나밖에 없고, 더 좋은 답이나 덜 좋은 답이 없으므로 Optimization problem이 아님
	* n개의 사과 중에서 r개를 골라서 무게의 합을 최대화 하는 문제 or 가장 무거운 사과와 가장 가벼운 사과의 무게 차이를 최소화하는 문는 Optimization problem
	* 최적화문제를 풀기위한 가장 기초적인 것이 완전탐색 : 가능한 답을 모두 생성해 보고 그중 가장 좋은 것을 찾아냄

* 자주등장하는 완전탐색유형
	* 모든 순열 만들기
		* 서로 다른 N개의 원소를 일렬로 줄 세운 것
		* 시간복잡도 : O(N!)
		* N이 10을 넘어간다면 완전탐색에 적합하지 않음
		* c++에서는 표준 라이브러리인 STL에 포함된 next_permutation() 함수에서 모든 순열을 순서대로 생성하는 작업을 해줌
	* 모든 조합 만들기
		* 서로 다른 N개의 원소에서 R개를 순서 없이 골라낸 것
		* 시간복잡도 : 이항계수 (N R)
	* 2^N가지 경우의 수 만들기
		* N개의 질문에 대한 답이 예/아니오 중의 하나라고 할 때 존재할 수 있는 모든 조합의 수
		* 시간복잡도 : O(2^N)

* 예제 <br/>
	1. 보글게임(BOGGLE) : solve(2017-10-03)
	2. 소풍(PICNIC) : solve(2017-10-04) 
	3. 게임판덮기(BOARDCOVER) : solve(2017-11-12)
	4. 여행하는 외판원 문제(Traveling Sales-man Problem, TSP) : solve(2017-10-04)
	5. 시계 맞추기(CLOCKSYNC) : solve(2018-01-18)
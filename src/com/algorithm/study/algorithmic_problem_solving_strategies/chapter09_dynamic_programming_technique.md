9장. 동적 계획법 테크닉

* 최적화 문제의 실제 답 계산하기
	* 최적화 문제를 풀 때 최적해의 점수(카운트)를 계산하는 것이 아니라 최적해를 직접 계산해야 할 경우
	(가장 긴 증가부분수열의 길이가 아닌 수열을 찾는경우)
	* 최적화 문제 답 계산하기 레시피
		1. 재귀 호출의 각 단계에서 최적해를 만들었던 선택을 별도의 배열에 저장해 둔다.
		2. 별도의 재귀 함수를 이용해 이 선택을 따라가며 각 선택지를 저장하거나 출력한다.
	* 관련 예제 : 1번
	
* K번째 답 계산하기
	* 범위에 포함되지 않는 부분은 skip하면서 구한다.
	* 관련 예제 : 3번, 4번, 5번
	
* 정수 이외의 입력에 대한 메모리제이션
	1. 연관 배열 사용
		* map과 같은 연관 배열을 사용하여 캐시를 구현
		* 간편하지만, map에 접근할 때마다 시간이 걸리는데다 map안에 list와 같은 자료구조를 넣으면 비교하는 데도 시간이 오래걸림
		* 계산량이 아주 작은 문제에만 사용 가능
	2. 일대일 대응 함수 작성
		* 입력을 적절하게 정수로 변환해 줄 수 있는 함수를 작성
		* 모든 입력의 종류에대해 각각 다른 정수로 변환하여(일대일 대응) 이를 메모리제이션
		* 예를 들면 정수 배열이 항상 [1,n] 범위의 수를 하나씩 가지고 있다면 입력의 종류는 n!이 됨 -> 입력 배열이 n!개의 가능한 입력 중 사전순으로 몇 번째인지를 반환하는 함수를 만들면 n!크기의 배열을 이용해서 메모리제이션을 할 수 있음
	3. 입력이 boolean값의 배열인 경우 (비트마스크)
		* boolean 변수는 true or false 이기 때문에 n개의 입력이 주어졌을 때 존재할 수 있는 입력의 가짓수는 2^n
		* 입력을 다른 방식으로 표현
			* 배열 -> 이진수표현 -> 대응되는 십진수
			* {true} -> 1 -> 1
			* {true, false, true, false} -> 0101 -> 5
			1. 길이 n인 배열을 길이가 n인 2진수로 이용
				* 실제로는 2진수 배열보다는 10진수를 이용하는 것이 훨씬 빠름
			2. 비트마스크 이용
				* 캐시에 입력에 대응되는 십진수의 index에 결과값을 저장하는 방식으로 메모리제이션
		* 2^n의 메모리가 필요하기 때문에 n이 20을 넘어가면 이 방법을 사용하기 어려움
		* n이 굉장히 작을 떄만 적용 가능
		* 원래의 시간 복잡도가 팩토리얼이거나 2보다 큰 밑을 사용하는 지수함수인 알고리즘을 메모리제이션 할 때 유용하게 쓰임
		* 관련 예제 : 6번, 7번, 8번
	4. 입력이 순열인 경우
		* 순열을 사전순으로 몇번째인지를 얻어서 이를 메모리제이션에 이용
	5. 입력의 범위가 좁은 경우
		* 입력의 범위가 좁으면 각 수를 나타내는 값을 배열의 인덱스로 쓰면 일대일 대응이 생김
		* 입력배열이 길이가 n이고 배열의 원소가 [0, k-1] 범위에 들어간다면 n자리의 k진수로 볼 수 있음
		
* 조합게임 (combination game)
	* 체스나 바둑, 오목처럼 두 사람의 참가자가 하는 게임
	* 게임의 상태가 주어졌을 때 완벽한 한 수를 찾아내는 알고리즘
	* 게임트리
		* 게임의 모든 상태를 트리형태로 그리는 것
		* 게임트리를 타고 내려가 게임에서 무조건 승리할 수 있는 한 수를 찾아내면 됨
		* 지난 상태로 되돌아 갈 수 있는 게임은(한번 둔 수를 물릴 수 있는 게임)지난 상태로 다시 돌아갈 수 있기 때문에 게임 트리에 사이클이 생길 수 있으므로 게임트리를 이용하기 힘듦
	* 관련 예제 : 9번, 10번, 11번
	
* 반복적 동적 계획법
	* 부분 문제 간의 의존성을 파악하기 쉬울 경우에는 재귀 함수가 아니라 반복문을 이용해서 동적 계획법을 구현 가능
	* 슬라이딩 윈도를 이용한 공간 복잡도 줄이기
		* 슬라이딩 윈도
			* 사용하는 데이터 전체를 메모리에 유지하는 것이 아니라 필요한 부분만을 저장하는 기법
			* 새 값을 계산할 떄 과거에 계산한 결과가 전부 필요한 것이 아니라 일부분만 필요할 때 사용 가능
		* 관련 예제 : 12번
	* 행렬 거듭제곱을 이용한 동적 계획법
		* 굉장히 한정된 경우에만 사용할 수 있지만 반복적 동적 계획법을 이용한 매우 유용한 트릭
		* 선형 변환(linear transform) 형태의 점화식을 행렬을 이용해 빠르게 푸는 기법
		* 적용예시) 피보나치수열
			* 참고자료 http://blog.naver.com/PostView.nhn?blogId=hist0134&logNo=220548083104

* 재귀적 동적 계획법의 장단접
	* 장점
		* 좀 더 직관적인 코드를 짤 수 있다.
		* 부분 문제 간의 의존 관계나 계산 순서에 대한 고민이 필요 없다.
		* 전체 부분 문제 중 일부의 답만 필요할 경우 더 빠르게 동작한다.
	* 단점
		* 슬라이딩 윈도 기법을 쓸 수 없다.
		* 스택 오버플로를 조심해야 한다.

* 반복적 동적 계획법의 장단점
	* 장점
		* 구현이 대개 더 짧다.
		* 재귀 호출에 필요한 부하가 없기 떄문에 조금 더 빠르게 동작한다.
		* 슬라이딩 윈도 기법을 쓸 수 있따.
	* 단점
		* 구현이 좀더 비직관적이다.
		* 부분 문제 간의 의존고나계를 고려해 계산되는 순서를 고민해야 된다.

* 예제
	1. 여행 짐 싸기 (PACKING) : solve(2017-10-17)
	2. 광학 문자 인식 (OCR)
	3. k번째 답 계산하기 (MORSE) : solve(2017-10-18)
	4. K번째 최대 증가 부분 수열 (KLIS)
	5. 드래곤 커브 (DRAGON) : solve(2017-10-25)
	6. 여행하는 외판원 문제(Traveling Sales-man Problem2, TSP2) : solve(2017-10-29)
	7. 웨브바짐 (ZIMBABWE) : solve(2017-10-30)
	8. 실험 데이터 복구하기 (RESTORE) : solve(2017-11-04)
	9. 틱택토 (TICTACTOE) : solve(2017-11-04)
	10. 숫자 게임 (NUMBERGAME) : solve(2017-11-08)
	11. 블록 게임 (BLOCKGAME) : solve(2017-11-09)
	12. 삼각형 위의 최대 경로(TRIANGLEPATH) : solve(2017-11-09)
	13. 회전초밥 (SUSHI) : solve(2017-10-10)
	14. 지니어스 (GENIUS)
	
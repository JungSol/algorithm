9장. 동적 계획법 테크닉

* 최적화 문제의 실제 답 계산하기
	* 최적화 문제를 풀 때 최적해의 점수(카운트)를 계산하는 것이 아니라 최적해를 직접 계산해야 할 경우
	(가장 긴 증가부분수열의 길이가 아닌 수열을 찾는경우)
	* 최적화 문제 답 계산하기 레시피
		1. 재귀 호출의 각 단계에서 최적해를 만들었던 선택을 별도의 배열에 저장해 둔다.
		2. 별도의 재귀 함수를 이용해 이 선택을 따라가며 각 선택지를 저장하거나 출력한다.
	* 관련 예제 : 1번
	
* K번째 답 계산하기
	* 범위에 포함되지 않는 부분은 skip하면서 구한다.
	* 관련 예제 : 3번, 4번, 5번
	
* 정수 이외의 입력에 대한 메모리제이션
	1. 연관 배열 사용
		* map과 같은 연관 배열을 사용하여 캐시를 구현
		* 간편하지만, map에 접근할 때마다 시간이 걸리는데다 map안에 list와 같은 자료구조를 넣으면 비교하는 데도 시간이 오래걸림
		* 계산량이 아주 작은 문제에만 사용 가능
	2. 일대일 대응 함수 작성
		* 입력을 적절하게 정수로 변환해 줄 수 있는 함수를 작성
		* 모든 입력의 종류에대해 각각 다른 정수로 변환하여(일대일 대응) 이를 메모리제이션
		* 예를 들면 정수 배열이 항상 [1,n] 범위의 수를 하나씩 가지고 있다면 입력의 종류는 n!이 됨 -> 입력 배열이 n!개의 가능한 입력 중 사전순으로 몇 번째인지를 반환하는 함수를 만들면 n!크기의 배열을 이용해서 메모리제이션을 할 수 있음
	3. 입력이 boolean값의 배열인 경우 (비트마스크)
		* boolean 변수는 true or false 이기 때문에 n개의 입력이 주어졌을 때 존재할 수 있는 입력의 가짓수는 2^n
		* 입력을 다른 방식으로 표현
			* 배열 -> 이진수표현 -> 대응되는 십진수
			* {true} -> 1 -> 1
			* {true, false, true, false} -> 0101 -> 5
			1. 길이 n인 배열을 길이가 n인 2진수로 이용
				* 실제로는 2진수 배열보다는 10진수를 이용하는 것이 훨씬 빠름
			2. 비트마스크 이용
				* 캐시에 입력에 대응되는 십진수의 index에 결과값을 저장하는 방식으로 메모리제이션
		* 2^n의 메모리가 필요하기 때문에 n이 20을 넘어가면 이 방법을 사용하기 어려움
		* n이 굉장히 작을 떄만 적용 가능
		* 원래의 시간 복잡도가 팩토리얼이거나 2보다 큰 밑을 사용하는 지수함수인 알고리즘을 메모리제이션 할 때 유용하게 쓰임
		* 관련 예제 : 6번
	4. 입력이 순열인 경우
		* 순열을 사전순으로 몇번째인지를 얻어서 이를 메모리제이션에 이용
	5. 입력의 범위가 좁은 경우
		* 입력의 범위가 좁으면 각 수를 나타내는 값을 배열의 인덱스로 쓰면 일대일 대응이 생김
		* 입력배열이 길이가 n이고 배열의 원소가 [0, k-1] 범위에 들어간다면 n자리의 k진수로 볼 수 있음

* 예제
	1. 여행 짐 싸기 (PACKING) : solve(2017-10-17)
	2. 광학 문자 인식 (OCR)
	3. k번째 답 계산하기 (MORSE) : solve(2017-10-18)
	4. K번째 최대 증가 부분 수열 (KLIS)
	5. 드래곤 커브 (DRAGON) : solve(2017-10-25)
	6. 여행하는 외판원 문제(Traveling Sales-man Problem2, TSP2) : solve(2017-10-29)
	7. 웨브바짐 (ZIMBABWE) : solve(2017-10-30)
	8. 실험 데이터 복구하기 (RESTORE)
	9. 틱택토 (TICTACTOE)
	10. 숫자 게임 (NUMBERGAME)
	11. 블록 게임 (BLOCKGAME)
	12. 삼각형 위의 최대 경로(TRIPATHCNT)
	13. 회전초밥 (SUSHI)
	14. 지니어스 (GENIUS)
	
16장. 비트마스크

* 비트마스크 (bit mask)
	* 정수의 이진수 표현을 자료구조로 쓰는 기법
	* 장점
		* 더 빠른 수행 시간
			* 비트마스크 연산은 O(1)에 구현되는 것이 많음
			* 비트마스크를 사용할 수 있다는 것은 원소의 수가 많지 않다는 뜻이기 때문에 엄청나게 큰 속도 향상을 기대할 수는 없지만, 연산을 굉장히 여러번 수행해야 할 경우에는 작은 최적화도 큰 속도 향상을 가져올 수 있음
		* 더 간결한 코드
			* 다양한 집합 연산들을 반복문 없이 한 줄에 쓸 수 있기 때문에 비트마스크를 사용하면 굉장히 짧은 코드를 작성 가능
		* 더 작은 메모리 사용량
			* 비트마스크를 이용하는 코드들은 같은 데이터를 더 적은 메모리를 사용해 구현 가능
			* 더 작은 메모리를 사용한다는 것은 더 많은 데이터를 미리 계산해서 저장해 둘 수 있음
				* 더 많은 데이터를 미리 계산해 둘 수 있으면 프로그램도 빨라지고, 더 적은 메모리를 사용하는 프로그램은 일반적으로 캐시 효율도 더 좋음
		* 연관 배열을 배열로 대체
			* boolean값 배열을 키로 갖는 연관 배열 객체 map<List<Boolean>, Integer>가 있다면, 비트마스크를 써서 같은 정보를 단순 int[]배열에 표현 가능
			* 엄ㅊ어난 시간과 메모리의 차이를 불러옴

* 용어 정리
	* 최상위 비트(most significant bit)
		* (부호 없는 n비트 정수형 변수는 n자리의 이진수로 쓸 수있는데, 비트가 표현하는 값은 2^0~2^n-1) 2^n-1에 해당하는 비트
	* 최하위 비트(least significant bit)
		* (부호 없는 n비트 정수형 변수는 n자리의 이진수로 쓸 수있는데, 비트가 표현하는 값은 2^0~2^n-1) 2^0에 해당하는 비트
	* 켜져있다
		* 어떤 비트의 위치가 1
	* 꺼져있다
		* 어떤 비트의 위치가 0
	
* 비트연산자
	* AND : &
	* OR : |
	* XOR : ^
	* NOT : ~
	* 왼쪽쉬프트 : << (빈자리 0으로)
	* 오른쪽쉬프트 : >> (빈자리 양수이면 0, 음수이면 1)
	* 오른쪽쉬픝 : >>> (빈자리 0으로. 원본데이터에 상관없이 결과는 unsigned)
	
* 비트마스크를 이용할 때 유의점
	* 연산자간의 우선순위
		* 비트연산자의 우선순위는 비교연산자(==, != 등)보다 낮음
	* 오버플로우에 주의
	
* 비트연산자를 사용하는 사례
	* 집합을 구현
		* 어떤 원소 i가 집합에 포함되어 있는지의 여부는 2^i를 나타내는 비트가 켜져있는지 여부로 나타냄
		* {1,4,5,6,7,9}를 표햔하는 정수 : 1011110010 = 754

* 비트연산 방법
	* 원소 추가
		* visit |= (1<<i)
	* 원소 삭제
		* visit &= ~(1<<i)
	* 원소 포함 여부 확인
		* visit & (1<<i) : 0이면 포함도지 않았고 1이상이면 포함됨
	* 원소 토글
		* visit ^= (1<<i)
	* 두집합에 대한 연산
		* 합집합 : a|b
		* 교집합 : a&b
		* 차집합(a-b) : a&~b
		* 하나에만포함된집합  : a^b

* 집합의 크기(원소의 크기)
	* 구현된 함수 사용
		* java : Integer.bitCount(bit)
	* (구현할때) 각 비트를 순회하면서 켜져있는 비트의 수를 직접 세야 함
		
		```
		int bitCount(int x) {
			if(x==0) return 0;
			return x%2 + bitCount(x/2);
		}
		```
* 최소원소 찾기
	* 집합에 포함된 가장 작은 원소를 찾는 것 (켜져있는 비트중에 가장 작은 비트를 찾는 것)
	* 최소 원소의 위치를 구하는 함수
		* java : Integer.numberOfTrailingZeros(bit)
	* 최소 원소를 구하는 코드
		1. 음수를 표햔하기 위해서는 2의 보수를 사용하는데, 2의 보수는 비트별 NOT연산을 적용한 후 그 결과에 1을 더해줌
		2. 최하위 비트가 i번째 비트라고 하면, i번째 비트는 1이며 0~i-1 비트는 0
		3. 비트별 not 연산을 적용하면, i번째 비트는 0이며 0~i-1 비트는 1
		4. 여기에 1을 더해주면 , i번째 비트는 1이며 0~i-1 비트는 1
		5. i번째 비트보다 상위 비트에는 not 연산이 적용된 상태이므로 두수를 and 하면 최하위 비트만 얻을 수 있음
				
		```
		int firstBit = (bit & -bit);
		```	

* 최소 원소 지우기
	* 최소 원소가 무엇인가에 상관 없이 최소 원소를 지우는 방법
	* 응용
		* 어떤 정수가 2의 제곱인지 확인
			* 2의 거듭제곱 값들은 이진수의 표현에 켜진 비트가 하나이므로 최하위 비트를 지웠을 때 0이 되어야 함
	* 코드
		1. bit - 1의 이진수 표현은 bit에서 켜져있는 최하위 비트를 끄고 그 밑의 비트를 전부 켠 것
		2. 따라서 두 값을 and 연산하면 최하위 비트와 그 이하 비트는 모두 0이 됨

		```
		bit &= (bit -1);
		```

* 모든 부분 집합 순회하기
	* 주어진 집합의 모든 부분 집합을 순회
	* 예를들면 {1,2,3}이면 {1}, {1,2}, {1,2,3}, {1,3}, {2}, {2,3}, {3}을 나열
	* 코드
		* 부분집합을 구하는 (subset-1)&bit에 대한 설명
			1. subset-1을 하면 최하위 비트가 꺼지고 그 밑의 비트들은 모두 켜짐
			2. 이 결과와 bit의 교집합을 구하면 그 중 bit에 속하지 않는 비트는 모두 꺼짐
			3. 1번과 2번을 반복하여 모든 부분집합을 구함
	
		```
		for(int subset = bit; bit != 0; bit = ((subset-1) & bit) {
			//subset은  bit의 부분집합
		}
		```

* 예제
	1. 
	
14장. 정수론

* 소수(prime number)
	* 양의 약수가 1과 자기 자신 두 개 뿐인 자연수
	* 2와 3을 제외한 모든 소수는 6k+1, 6k-1의 형태를 띔

* 합성수(composite number)
	* 세 개 이상의 양의 약수를 갖는 자연수
	
* 소수 판별 (주어진 n이 소수인가?)
	* 다양한 방법이 있는데 대부분의 효율적인 방법들은 너무 복잡한 관계로 프로그래밍 대회에는 출제되지 않음
	* 방법1) 2부터 루트n 까지의 모든 수를 순회하면서 이 중 n의 약수가 있는지 확인 -> 약수가 하나도 없다면 소수
		* 왜 루트n? 합성수 n이 pxq로 표현될 때 한 수는 루트n이하, 한 수는 루트n이상이므로 절반인 루트n까지만 순회하면 됨
		* n이 32비트 정수 범위 내의 수라고 하면 루트n은 2^16 = 65,536 (컴퓨터가 계산하기엔 짧음)
	* 방법2) 에라토스테네스의 체 이용
		* 에라토스테네스의 체는 아래 참고
		* 방법1의 소수판별 알고리즘을 [2,n] 범위의 모든 자연수에 대해 확장한 것
			* 각 수 i이 소수인지 판단하기 위해 루트i까지의 모든 수로 나눠보는 대신, 소수를 찾을 때마다 그 배수들을 지우는 형태로 동작하기 때문에 훨씬 빠르게 수행
		* 에라토스테네스의 체를 이용하여 n이하의 소수들리스트를 만들고 나면(시간복잡도 O(nloglogn)) 리스트에 접근하여 원하는 수가 소수인지 아닌지 O(1)만에 판별가능
		
* 소인수 분해(prime fac-torization)
	* 합성수를 소수들의 곱으로 표현하는 방법
	* ex) 4=2*2  15=3*5

* 소인수 분해 구현
	* 방법1) 2부터 시작해서 n의 소인수가 될 수 있는 수들을 하나하나 순회하면서, n의 약수를 찾을 때마다 n을 이 숫자로 나눠줌
	* 방법2) 에라토스테네스의 체 이용
		* 에라토스테네스의 체는 아래 참고
		* 에라토스테네스의 체를 이용하여 n+1크기의 배열에 각 index마다 각 숫자의 가장 작은 소인수를 기록해두고, 이를 이용하여 빠르게 소인수분해를 수행한다.
		
* 소인수 분해와 약수의 개수
	* 소인수 분해 각 항의 승+1을 곱해주면 약수의 개수가 된다.
	* 예시) 67500 = 2^2 \* 3^3 \* 5^4
		* 해당 수의 약수의 개수는 (2+1) \* (3+1) \* (4+1) = 60
	
* 에라토스테네스의 체
	* 소수 관련 문제를 풀 때 가장 많이 사용되는 방법
	* 주어진 수 n 이하의 소수들을 모두 찾아내는 방법
	* 시간복잡도는 매우 빠르지만 메모리가 많이 차지
		* 많은 수에 대해 에라토스테네스의 체를 수행해야 할 때 메모리 사용을 줄이는 방법
			1. 2를 제외한 짝수는 모두 합성수이므로 짝수를 별도로 처리해서 필요한 배열의 크기를 1/2로 줄임
			2. 비트마스크를 사용하여 줄임
	* 구현방법
		1. 2부터 n까지의 수를 쭉 나열한다.
		2. 목록에서 지워지지 않은 수들을 순회하며 이 수의 배수들을 제거한다.
		3. 2번을 2부터 n까지 반복하면 남는 수들은 소수가 된다.
		
* 유클리드 알고리즘 (Euclidean Alogrithm)
	* 두 수의 최대공약수를 구하는 방법
	* 두 수 p, q(p>q)의 공약수의 집합은 p-q와 q의 공약수 집합과 같다는 점을 이용
	* p, q의 최대공약수 gcd(p,q)는 항상 p-q와 q의 최대 공약수 gcd(p-q, q)와 같다.

* 유클리드 알고리즘을 이용한 최대공약수의 계산 과정
	1. gcd(6,15) = gcd(9,6) = gcd(3,6) = gcd(3,3) = gcd(0,3)
	2. 어느 한 수가 0이되면 gcd(0,x)는 x이므로 최대공약수를 구할 수 있게됨
	3. gcd를 호출할 때 마다 앞수가 뒷수보다 크도록 swap이 필요하다.
	
* 유클리드 알고리즘의 개선
	1. gcd(p,q) = gcd(q, p%q)로 표현 가능
	2. 이를 이용하면 최대공약수를 계산하는 과정을 줄일 수 있음
	3. p%q는 q보다 반드시 작으므로 gcd(q, p%q)를 호출하면 앞수가 뒷수보다 크다는게 보장된다.

* 모듈라 연산 (modular arithmetic)
	* 모듈로(moduleus) M에 도달하면 다시 0으로 돌아가는 정수를 가지고 하는 연산
	* 모듈라 연산에서 모든 정수는 M으로 나눈 나머지로 표현됨
	* 예시) 24시간 시계 : 시간에서 25시나 42는 없음. 각각 1시나 18시로 표현해야 함
	
* 모듈라 연산의 목적
	* 무한히 큰 정수를 다룰 수 없는 컴퓨터의 특성으로 인해 프로그래밍 대회에 종종 출현
	* 64비트 정수형으로도 표현할 수 없는 정수를 다뤄야 하는 문제의 경우, 답을 직접 계산하려면 큰 정수 자료구조를 구현해야 하는데 이것이 매두 까다로운 작업이기 때문
	
* 모듈라 덧셈, 뺄셈 그리고 곱셈
	* 덧셈
		* (a+b)%M = (a%M + b%M)%M
	* 뺄셈
		* (a-b)%M = (a%M - b%M + M)%M
		* 뺄셈의 결과가 음수여서 음수를 나누는 것을 방지하기 위해서 M을 더해준 후 다시 나눈다.
		* 어차피 M은 M으로 나누면 나머지가 0이므로 M을 더해줘도 결과에 영향을 미치지 않는다.
	* 곱셈
		* (a\*b)%M = (a%M \* b%M)%M
		* (a%M \* b%M)%M를 이용하여도 오버플로우의 위험이 있다면 고대 이집트 곱셈법 이용(training.skill.multiplication)
	* 나눗셈
		* 덧셈과 뺄셈 곱셈의 일반적인 공식이 성립하지 않는다.
		* a/b는 b로 a를 나누는 대신 곱셈 역원(multiplicative inverse)을 곱하는 방식으로 이루어 짐
			* b의 곱셈 역원은 항상 존재하는 것이 아니라, b와 M이 서로소일 때만 존재한다.
		* 프로그래밍 대회에서 출제되는 대부분의 문제에서는 M이 소수인데 이 경우 b의 역원
			* modInv(b,M) = (b^(M-2))%M
		* b와 M이 서로소일 때 모듈라 연산 (페르마의 소정리)
			* (a/b)%M = (a\*modInv(b,M))%M
		* b와 M이 서로소가 아닐 때의 모듈라 연산
			* A\*b + B\*M = 1 (mod M) 를 만족하는 A를 찾으면 됨
		* 참고자료
			* http://kdh9949.tistory.com/17
	
* 예제
	1. 소수판별(is_prime) : solve(2017-11-05)
	2. 소인수분해 구하기(cal_factor) : sovle(2017-11-05)
	3. 에라토스테네스의 체 구현 (eratosthenes) : solve(2017-11-05)	
	4. 최대공약수 구하기(get_gcd) : solve(2017-11-10)
	4. 마법의 약(POTION) : solve(2017-11-11)